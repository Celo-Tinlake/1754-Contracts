{"compiler":{"version":"0.8.13+commit.abaa5c0e"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"loan","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newRate","type":"uint256"}],"name":"ChangeRate","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"loan","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"currencyAmount","type":"uint256"}],"name":"DecreaseDebt","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"usr","type":"address"}],"name":"Deny","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"what","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"rate","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"File","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"loan","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"currencyAmount","type":"uint256"}],"name":"IncreaseDebt","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"usr","type":"address"}],"name":"Rely","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"loan","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"rate","type":"uint256"}],"name":"SetRate","type":"event"},{"inputs":[{"internalType":"uint256","name":"loan","type":"uint256"}],"name":"accrue","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"loan","type":"uint256"},{"internalType":"uint256","name":"newRate","type":"uint256"}],"name":"changeRate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"interestBearingAmount","type":"uint256"},{"internalType":"uint256","name":"ratePerSecond","type":"uint256"},{"internalType":"uint256","name":"lastUpdated","type":"uint256"}],"name":"chargeInterest","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chi","type":"uint256"},{"internalType":"uint256","name":"ratePerSecond","type":"uint256"},{"internalType":"uint256","name":"lastUpdated","type":"uint256"},{"internalType":"uint256","name":"pie","type":"uint256"}],"name":"compounding","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"loan","type":"uint256"}],"name":"debt","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"loan","type":"uint256"},{"internalType":"uint256","name":"currencyAmount","type":"uint256"}],"name":"decDebt","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"usr","type":"address"}],"name":"deny","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"rate","type":"uint256"}],"name":"drip","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"what","type":"bytes32"},{"internalType":"uint256","name":"rate","type":"uint256"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"file","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"loan","type":"uint256"},{"internalType":"uint256","name":"currencyAmount","type":"uint256"}],"name":"incDebt","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"loanRates","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"loan","type":"uint256"},{"internalType":"uint256","name":"ratePerSecond","type":"uint256"},{"internalType":"uint256","name":"fixedRate","type":"uint256"}],"name":"newLoan","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"pie","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"rate","type":"uint256"}],"name":"rateDebt","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"rates","outputs":[{"internalType":"uint256","name":"pie","type":"uint256"},{"internalType":"uint256","name":"chi","type":"uint256"},{"internalType":"uint256","name":"ratePerSecond","type":"uint256"},{"internalType":"uint48","name":"lastUpdated","type":"uint48"},{"internalType":"uint256","name":"fixedRate","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"rdiv","outputs":[{"internalType":"uint256","name":"z","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"usr","type":"address"}],"name":"rely","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"rmul","outputs":[{"internalType":"uint256","name":"z","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"n","type":"uint256"},{"internalType":"uint256","name":"base","type":"uint256"}],"name":"rpow","outputs":[{"internalType":"uint256","name":"z","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"safeAdd","outputs":[{"internalType":"uint256","name":"z","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"safeDiv","outputs":[{"internalType":"uint256","name":"z","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"safeMul","outputs":[{"internalType":"uint256","name":"z","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"safeSub","outputs":[{"internalType":"uint256","name":"z","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"loan","type":"uint256"},{"internalType":"uint256","name":"rate","type":"uint256"}],"name":"setRate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chi","type":"uint256"},{"internalType":"uint256","name":"pie","type":"uint256"}],"name":"toAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"chi","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"toPie","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"wards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"src/Interest/InterestModule.sol":"InterestModule"},"evmVersion":"london","libraries":{":__CACHE_BREAKER__":"0x00000000d41867734bbee4c6863d9255b2b06ac1"},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":5000},"remappings":[]},"sources":{"@1754-factory/packages/src/auth/auth.sol":{"content":"// SPDX-License-Identifier: None\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\npragma solidity ^0.8.10;\n\ncontract Auth {\n    mapping (address => uint256) public wards;\n    \n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"not-authorized\");\n        _;\n    }\n\n}","keccak256":"0x613c3d19c8f965f6b2e23fc0362bb353448bec2b1945d694a8c1bc428a486b47","license":"None"},"@1754-factory/packages/src/math/interest.sol":{"content":"// SPDX-License-Identifier: None\n// Copyright (C) 2018 Rain <rainbreak@riseup.net> and Centrifuge, referencing MakerDAO dss => https://github.com/makerdao/dss/blob/master/src/pot.sol\npragma solidity ^0.8.10;\n\nimport \"./math.sol\";\n\ncontract Interest is Math {\n    // @notice This function provides compounding in seconds\n    // @param chi Accumulated interest rate over time\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10\u02c627)\n    // @param lastUpdated When the interest rate was last updated\n    // @param pie Total sum of all amounts accumulating under one interest rate, divided by that rate\n    // @return The new accumulated rate, as well as the difference between the debt calculated with the old and new accumulated rates.\n    function compounding(uint chi, uint ratePerSecond, uint lastUpdated, uint pie) public view returns (uint, uint) {\n        require(block.timestamp >= lastUpdated, \"tinlake-math/invalid-timestamp\");\n        require(chi != 0);\n        // instead of a interestBearingAmount we use a accumulated interest rate index (chi)\n        uint updatedChi = _chargeInterest(chi ,ratePerSecond, lastUpdated, block.timestamp);\n        return (updatedChi, safeSub(rmul(updatedChi, pie), rmul(chi, pie)));\n    }\n\n    // @notice This function charge interest on a interestBearingAmount\n    // @param interestBearingAmount is the interest bearing amount\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10\u02c627)\n    // @param lastUpdated last time the interest has been charged\n    // @return interestBearingAmount + interest\n    function chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated) public view returns (uint) {\n        if (block.timestamp >= lastUpdated) {\n            interestBearingAmount = _chargeInterest(interestBearingAmount, ratePerSecond, lastUpdated, block.timestamp);\n        }\n        return interestBearingAmount;\n    }\n\n    function _chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated, uint current) internal pure returns (uint) {\n        return rmul(rpow(ratePerSecond, current - lastUpdated, ONE), interestBearingAmount);\n    }\n\n\n    // convert pie to debt/savings amount\n    function toAmount(uint chi, uint pie) public pure returns (uint) {\n        return rmul(pie, chi);\n    }\n\n    // convert debt/savings amount to pie\n    function toPie(uint chi, uint amount) public pure returns (uint) {\n        return rdivup(amount, chi);\n    }\n\n    function rpow(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                let xx := mul(x, x)\n                if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                let xxRound := add(xx, half)\n                if lt(xxRound, xx) { revert(0,0) }\n                x := div(xxRound, base)\n                if mod(n,2) {\n                    let zx := mul(z, x)\n                    if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                    let zxRound := add(zx, half)\n                    if lt(zxRound, zx) { revert(0,0) }\n                    z := div(zxRound, base)\n                }\n            }\n            }\n        }\n    }\n}","keccak256":"0x77562693465eeeb82f2dbefe45623e4ad3cf1af56c72224a2306f6202fe1d7a3","license":"None"},"@1754-factory/packages/src/math/math.sol":{"content":"// SPDX-License-Identifier: None\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\npragma solidity ^0.8.10;\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}","keccak256":"0x3dc23f1e3bf4b4f3bbb0fde10c71b971253011c9e22e978bf7f29730b426332d","license":"None"},"src/Interest/InterestModule.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) 2018  Rain <rainbreak@riseup.net>, Centrifuge\npragma solidity ^0.8.13;\n\nimport \"@1754-factory/packages/src/math/interest.sol\";\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\n// ## Interest Group based Pile\n// The following is one implementation of a debt module. It keeps track of different buckets of interest rates and is optimized for many loans per interest bucket. It keeps track of interest\n// rate accumulators (chi values) for all interest rate categories. It calculates debt each\n// loan according to its interest rate category and pie value.\ncontract InterestModule is Auth, Interest {\n    // --- Data ---\n\n    // stores all needed information of an interest rate group\n    struct Rate {\n        uint256 pie; // Total debt of all loans with this rate\n        uint256 chi; // Accumulated rates\n        uint256 ratePerSecond; // Accumulation per second\n        uint48 lastUpdated; // Last time the rate was accumulated\n        uint256 fixedRate; // fixed rate applied to each loan of the group\n    }\n\n    // Interest Rate Groups are identified by a `uint` and stored in a mapping\n    mapping(uint256 => Rate) public rates;\n\n    // mapping of all loan debts\n    // the debt is stored as pie\n    // pie is defined as pie = debt/chi therefore debt = pie * chi\n    // where chi is the accumulated interest rate index over time\n    mapping(uint256 => uint256) public pie;\n    // loan => rate\n    mapping(uint256 => uint256) public loanRates;\n\n    // Events\n    event IncreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event DecreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event SetRate(uint256 indexed loan, uint256 rate);\n    event ChangeRate(uint256 indexed loan, uint256 newRate);\n    event File(bytes32 indexed what, uint256 rate, uint256 value);\n\n    constructor() {\n        // pre-definition for loans without interest rates\n        rates[0].chi = ONE;\n        rates[0].ratePerSecond = ONE;\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Public Debt Methods  ---\n    // increases the debt of a loan by a currencyAmount\n    // a change of the loan debt updates the rate debt and total debt\n    function incDebt(uint256 loan, uint256 currencyAmount) external auth {\n        uint256 rate = loanRates[loan];\n        require(\n            block.timestamp == rates[rate].lastUpdated,\n            \"rate-group-not-updated\"\n        );\n        currencyAmount = (currencyAmount +\n            rmul(currencyAmount, rates[rate].fixedRate));\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = (pie[loan] + pieAmount);\n        rates[rate].pie = (rates[rate].pie + pieAmount);\n\n        emit IncreaseDebt(loan, currencyAmount);\n    }\n\n    // decrease the loan's debt by a currencyAmount\n    // a change of the loan debt updates the rate debt and total debt\n    function decDebt(uint256 loan, uint256 currencyAmount) external auth {\n        uint256 rate = loanRates[loan];\n        require(\n            block.timestamp == rates[rate].lastUpdated,\n            \"rate-group-not-updated\"\n        );\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = (pie[loan] + pieAmount);\n        rates[rate].pie = (rates[rate].pie + pieAmount);\n\n        emit DecreaseDebt(loan, currencyAmount);\n    }\n\n    // returns the current debt based on actual block.timestamp (now)\n    function debt(uint256 loan) external view returns (uint256) {\n        uint256 rate_ = loanRates[loan];\n        uint256 chi_ = rates[rate_].chi;\n        if (block.timestamp >= rates[rate_].lastUpdated) {\n            chi_ = chargeInterest(\n                rates[rate_].chi,\n                rates[rate_].ratePerSecond,\n                rates[rate_].lastUpdated\n            );\n        }\n        return toAmount(chi_, pie[loan]);\n    }\n\n    // returns the total debt of a interest rate group\n    function rateDebt(uint256 rate) external view returns (uint256) {\n        uint256 chi_ = rates[rate].chi;\n        uint256 pie_ = rates[rate].pie;\n\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            chi_ = chargeInterest(\n                rates[rate].chi,\n                rates[rate].ratePerSecond,\n                rates[rate].lastUpdated\n            );\n        }\n        return toAmount(chi_, pie_);\n    }\n\n    // --- Interest Rate Group Implementation ---\n\n    // set rate loanRates for a loan\n    function setRate(uint256 loan, uint256 rate) external auth {\n        require(pie[loan] == 0, \"non-zero-debt\");\n        // rate category has to be initiated\n        require(rates[rate].chi != 0, \"rate-group-not-set\");\n        loanRates[loan] = rate;\n        emit SetRate(loan, rate);\n    }\n\n    // change rate loanRates for a loan\n    function changeRate(uint256 loan, uint256 newRate) external auth {\n        require(rates[newRate].chi != 0, \"rate-group-not-set\");\n        uint256 currentRate = loanRates[loan];\n        drip(currentRate);\n        drip(newRate);\n        uint256 pie_ = pie[loan];\n        uint256 debt_ = toAmount(rates[currentRate].chi, pie_);\n        rates[currentRate].pie = (rates[currentRate].pie + pie_);\n        pie[loan] = toPie(rates[newRate].chi, debt_);\n        rates[newRate].pie = (rates[newRate].pie + pie[loan]);\n        loanRates[loan] = newRate;\n        emit ChangeRate(loan, newRate);\n    }\n\n    function newLoan(\n        uint256 loan,\n        uint256 ratePerSecond,\n        uint256 fixedRate\n    ) external auth {\n        rates[loan].chi = ONE;\n        rates[loan].lastUpdated = uint48(block.timestamp);\n        rates[loan].ratePerSecond = ONE; //ratePerSecond - ratePerSecond;\n        rates[loan].fixedRate = fixedRate;\n        loanRates[loan] = loan;\n    }\n\n    // set/change the interest rate of a rate category\n    function file(\n        bytes32 what,\n        uint256 rate,\n        uint256 value\n    ) external auth {\n        if (what == \"rate\") {\n            require(value != 0, \"rate-per-second-can-not-be-0\");\n            if (rates[rate].chi == 0) {\n                rates[rate].chi = ONE;\n                rates[rate].lastUpdated = uint48(block.timestamp);\n            } else {\n                drip(rate);\n            }\n            rates[rate].ratePerSecond = value;\n        } else if (what == \"fixedRate\") {\n            rates[rate].fixedRate = value;\n        } else revert(\"unknown parameter\");\n\n        emit File(what, rate, value);\n    }\n\n    // accrue needs to be called before any debt amounts are modified by an external component\n    function accrue(uint256 loan) external {\n        drip(loanRates[loan]);\n    }\n\n    // drip updates the chi of the rate category by compounding the interest and\n    // updates the total debt\n    function drip(uint256 rate) public {\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            (uint256 chi, ) = compounding(\n                rates[rate].chi,\n                rates[rate].ratePerSecond,\n                rates[rate].lastUpdated,\n                rates[rate].pie\n            );\n            rates[rate].chi = chi;\n            rates[rate].lastUpdated = uint48(block.timestamp);\n        }\n    }\n}\n","keccak256":"0xd4783779ee94a73312ca060b12f6c3891ab945eee8e828b03416c87d33203a24","license":"AGPL-3.0-only"}},"version":1}