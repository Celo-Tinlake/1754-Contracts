{
  "language": "Solidity",
  "sources": {
    "src/Borrowers/ERC721Credit.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../Structures/CreditorStructures.sol\";\n\ncontract ERC721Credit is ERC721, CreditorStructures {\n    mapping(uint256 => Credit) creditData; // Maps tokenIds to credit structure\n    address minter;\n    uint256 linesOfCredit;\n\n    constructor(address _minter) ERC721(\"1754 Bullet Loan Credit Receipts\", \"bFACT\") {\n        minter = _minter;\n        linesOfCredit = 0;\n    }\n\n    modifier only_minter() {\n        require(msg.sender == minter, \"Unauthorized\");\n        _;\n    }\n\n    function getCreditInfo(uint256 tokenId)\n        external\n        view\n        returns (Credit memory credit, address owner)\n    {\n        require(_exists(tokenId), \"Line of credit does not exist\");\n        credit = creditData[tokenId];\n        owner = ownerOf(tokenId);\n    }\n\n    function setAmountClaimed(uint256 tokenId, uint256 amountClaimed)\n        external\n        only_minter\n    {\n        require(_exists(tokenId), \"Line of credit does not exist\");\n        Credit storage credit = creditData[tokenId];\n        credit.amountClaimed = amountClaimed;\n    }\n\n    function mint(CreditorStructures.CreditMintParams calldata params)\n        external\n        only_minter\n        returns (uint256)\n    {\n        Credit storage credit = creditData[linesOfCredit];\n        credit.amountSupplied = params.amountSupplied;\n        credit.loanId = params.loanId;\n        _mint(params.creditor, linesOfCredit);\n        return linesOfCredit++;\n    }\n\n    function burn(uint256 tokenId) external only_minter {\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "src/Structures/CreditorStructures.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.13;\n\ninterface CreditorStructures {\n    struct Credit {\n        uint256 loanId; // id of loan associated with\n        uint256 amountSupplied;\n        uint256 amountClaimed;\n        uint256 lastClaimedAt;\n    }\n\n    struct CreditMintParams {\n        uint256 loanId;\n        uint256 amountSupplied;\n        address creditor;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/Borrowers/MicroLoanFactory.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.10;\n\nimport \"./IERC721Credit.sol\";\nimport \"../Structures/CreditorStructures.sol\";\nimport \"../Structures/LoanStructures.sol\";\nimport \"../Structures/MicroLoanEvents.sol\";\nimport \"./ERC721Credit.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface InterestModuleLike {\n    function incDebt(uint256 loan, uint256 currencyAmount) external;\n\n    function decDebt(uint256 loan, uint256 currencyAmount) external;\n\n    function debt(uint256 loan) external view returns (uint256);\n\n    function rateDebt(uint256 rate) external view returns (uint256);\n\n    function setRate(uint256 loan, uint256 rate) external;\n\n    function changeRate(uint256 loan, uint256 newRate) external;\n\n    function accrue(uint256 loan) external;\n\n    function newLoan(\n        uint256 loan,\n        uint256 ratePerSecond,\n        uint256 fixedRate\n    ) external;\n}\n\ncontract MicroLoanFactory is LoanStructures, MicroLoanEvents, Ownable {\n    mapping(uint256 => Loan) public loans;\n    mapping(uint256 => LoanRequest) public requestsById;\n    mapping(address => uint256) public requestsByAddress;\n    mapping(address => int256) public creditScores;\n    mapping(address => bool) public attestors;\n    uint256 public interestRate = 10**9; // 10% interest rate\n    address public settlementToken;\n    address public creditToken;\n    uint256 public IDs;\n    InterestModuleLike public interestModule;\n\n    event AttestorAdded(address indexed attestor);\n    event AttestorRemoved(address indexed attestor);\n\n    constructor(address token, address _interestModule) Ownable() {\n        settlementToken = token;\n        IDs = 1;\n        interestModule = InterestModuleLike(_interestModule);\n        ERC721Credit credit = new ERC721Credit(address(this));\n        creditToken = address(credit);\n    }\n\n    modifier loanExists(uint256 id) {\n        require(loans[id].start > 0, \"Loan does not exist\");\n        _;\n    }\n\n    modifier requestExists(uint256 id) {\n        require(\n            requestsById[id].borrower != address(0),\n            \"Request does not exist\"\n        );\n        _;\n    }\n\n    modifier attestor(address addr) {\n        require(attestors[addr], \"Not an attestor\");\n        _;\n    }\n\n    function setCreditToken(address token) external onlyOwner {\n        creditToken = token;\n    }\n\n    function getAmountOwed(uint256 id) public view returns (uint256) {\n        if (loans[id].closed || loans[id].id == 0) {\n            return 0;\n        }\n\n        return interestModule.debt(id);\n    }\n\n    function addAttestor(address newAttestor) external onlyOwner {\n        require(!attestors[newAttestor], \"Already an attestor\");\n        attestors[newAttestor] = true;\n\n        emit AttestorAdded(newAttestor);\n    }\n\n    function removeAttestor(address toRemove)\n        external\n        onlyOwner\n        attestor(toRemove)\n    {\n        attestors[toRemove] = false;\n\n        emit AttestorRemoved(toRemove);\n    }\n\n    function attest(\n        uint256 loanId,\n        uint256 score,\n        bytes calldata details\n    ) external attestor(msg.sender) {\n        emit Attestation(loanId, msg.sender, score, details);\n    }\n\n    function requestLoan(\n        LoanPurpose purpose,\n        uint256 amount,\n        uint256 duration\n    ) external returns (uint256 loanId){\n        loanId = IDs;\n        LoanRequest storage request = requestsById[IDs];\n        request.amount = amount;\n        request.borrower = msg.sender;\n        request.purpose = purpose;\n        request.duration = duration;\n\n        requestsByAddress[msg.sender] = loanId;\n        emit LoanRequested(\n            IDs,\n            msg.sender,\n            block.timestamp,\n            amount,\n            interestRate\n        );\n        IDs++;\n    }\n\n    function _fulfillLoan(uint256 id) internal requestExists(id) {\n        LoanRequest storage request = requestsById[id];\n        require(\n            loans[requestsByAddress[request.borrower]].start == 0 &&\n                loans[id].start == 0,\n            \"User has an outstanding loan\"\n        );\n        Loan storage loan = loans[id];\n        loan.start = block.timestamp;\n        loan.deadline = block.timestamp + request.duration;\n        loan.id = id;\n        loan.borrower = request.borrower;\n        loan.purpose = request.purpose;\n        loan.amount = request.amount;\n        interestModule.newLoan(id, interestRate, interestRate);\n        interestModule.incDebt(id, loan.amount);\n\n        IERC20(settlementToken).transfer(request.borrower, request.amount);\n        emit LoanFulfilled(\n            id,\n            block.timestamp,\n            request.borrower,\n            request.amount\n        );\n    }\n\n    function contribute(uint256 id, uint256 amount) external returns (uint256) {\n        LoanRequest storage request = requestsById[id];\n        uint256 amountToFill = request.amount - request.amountFilled;\n        uint256 fillAmount = amount > amountToFill ? amountToFill : amount;\n        require(\n            IERC20(settlementToken).transferFrom(\n                msg.sender,\n                address(this),\n                fillAmount\n            )\n        );\n        request.amountFilled += fillAmount;\n        if (request.amountFilled == request.amount) {\n            _fulfillLoan(id);\n        }\n        return IERC721Credit(creditToken).mint(\n            CreditorStructures.CreditMintParams({\n                loanId: id,\n                amountSupplied: fillAmount,\n                creditor: msg.sender\n            })\n        );\n    }\n\n    function calculateInterest(uint256 id) internal view returns (uint256) {\n        return interestModule.debt(id);\n    }\n\n    function closeLoan(uint256 id) internal {\n        Loan storage loan = loans[id];\n        loan.closed = true;\n        uint256 elapsedTime = block.timestamp - loan.start;\n        int256 creditChange = int256(block.timestamp) - int256(loan.start);\n        creditScores[loan.borrower] =\n            creditScores[loan.borrower] +\n            creditChange;\n        emit LoanFullyPaid(\n            id,\n            block.timestamp,\n            loan.borrower,\n            loan.amount,\n            elapsedTime,\n            creditChange\n        );\n    }\n\n    function repayLoan(uint256 id, uint256 amount) external {\n        Loan storage loan = loans[id];\n        interestModule.accrue(id);\n        uint256 totalOwed = interestModule.debt(id);\n        require(totalOwed > 0, \"Does not owe anything\");\n        uint256 amountPaid = amount > totalOwed ? totalOwed : amount;\n        loan.totalPaid += amountPaid;\n        require(\n            IERC20(settlementToken).transferFrom(\n                loan.borrower,\n                address(this),\n                amountPaid\n            )\n        );\n        interestModule.decDebt(id, amountPaid);\n        if (amountPaid == totalOwed) {\n            closeLoan(id);\n        }\n        emit LoanPaymentMade(\n            id,\n            block.timestamp,\n            loan.borrower,\n            amountPaid,\n            totalOwed - amountPaid\n        );\n    }\n\n    function claimCredit(uint256 creditId) external returns (uint256) {\n        (\n            CreditorStructures.Credit memory credit,\n            address owner\n        ) = IERC721Credit(creditToken).getCreditInfo(creditId);\n        Loan storage loan = loans[credit.loanId];\n        uint256 effectiveAmount = loan.totalPaid - credit.lastClaimedAt;\n        uint256 entitledTo = (credit.amountSupplied * effectiveAmount) /\n            loan.amount;\n\n        credit.lastClaimedAt = loan.totalPaid;\n        IERC721Credit(creditToken).setAmountClaimed(creditId, entitledTo);\n        IERC20(settlementToken).transfer(owner, entitledTo);\n        return entitledTo;\n    }\n}\n"
    },
    "src/Borrowers/IERC721Credit.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../Structures/CreditorStructures.sol\";\n\ninterface IERC721Credit is IERC721, CreditorStructures {\n    function getCreditInfo(uint256 tokenId)\n        external\n        view\n        returns (Credit memory credit, address owner);\n\n    function mint(CreditorStructures.CreditMintParams calldata params)\n        external\n        returns (uint256);\n\n    function burn(uint256 tokenId) external;\n\n    function setAmountClaimed(uint256 tokenId, uint256 amountClaimed) external;\n}\n"
    },
    "src/Structures/LoanStructures.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\n// license: MIT\n\npragma solidity ^0.8.13;\n\ncontract LoanStructures {\n    uint256 public constant PERCENT_DENOMINATOR = 10**10;\n\n    struct OutstandingLoan {\n        uint256 amount;\n        uint256 time;\n    }\n\n    enum LoanPurpose {\n        FOOD,\n        WATER,\n        HEALTH,\n        SCHOOL,\n        BILLS,\n        TRANSPORT,\n        OTHER\n    }\n\n    struct Tranche {\n        uint256 percent;\n        uint256 weight;\n    }\n\n    struct Loan {\n        uint256 start;\n        uint256 deadline;\n        uint256 id;\n        address borrower;\n        uint256 totalPaid;\n        LoanPurpose purpose;\n        bool closed;\n        uint256 amount;\n    }\n\n    struct LoanRequest {\n        uint256 amount;\n        uint256 amountFilled;\n        address borrower;\n        uint256 duration;\n        LoanPurpose purpose;\n    }\n}\n"
    },
    "src/Structures/MicroLoanEvents.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.13;\n\ninterface MicroLoanEvents {\n    event LoanRequested(\n        uint256 indexed id,\n        address indexed requestor,\n        uint256 timestamp,\n        uint256 amount,\n        uint256 rate\n    );\n\n    event Attestation(\n        uint256 indexed loanId,\n        address indexed attestor,\n        uint256 indexed score,\n        bytes details\n    );\n\n    event LoanFulfilled(\n        uint256 indexed id,\n        uint256 time,\n        address indexed borrower,\n        uint256 amount\n    );\n    event LoanPaymentMade(\n        uint256 indexed id,\n        uint256 time,\n        address indexed borrower,\n        uint256 indexed amountPaid,\n        uint256 outstandingLoanAmount\n    );\n    event LoanFullyPaid(\n        uint256 indexed id,\n        uint256 time,\n        address indexed borrower,\n        uint256 amountBorrowed,\n        uint256 elapsedTime,\n        int256 changeToCredit\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "src/TinlakeDeployer/TinlakeDeployer.sol": {
      "content": "pragma solidity ^0.8.13;\n\nimport \"@1754-factory/tinlake/src/root.sol\";\nimport {LenderDeployer} from \"@1754-factory/tinlake/src/lender/deployer.sol\";\nimport {BorrowerDeployer} from \"@1754-factory/tinlake/src/borrower/deployer.sol\";\n\nimport {TrancheFab} from \"@1754-factory/tinlake/src/lender/fabs/tranche.sol\";\nimport {MemberlistFab} from \"@1754-factory/tinlake/src/lender/fabs/memberlist.sol\";\nimport {ReserveFab} from \"@1754-factory/tinlake/src/lender/fabs/reserve.sol\";\nimport {AssessorFab} from \"@1754-factory/tinlake/src/lender/fabs/assessor.sol\";\nimport {PoolAdminFab} from \"@1754-factory/tinlake/src/lender/fabs/pooladmin.sol\";\nimport {CoordinatorFab} from \"@1754-factory/tinlake/src/lender/fabs/coordinator.sol\";\nimport {OperatorFab} from \"@1754-factory/tinlake/src/lender/fabs/operator.sol\";\n\nimport {ShelfFab} from \"@1754-factory/tinlake/src/borrower/fabs/shelf.sol\";\nimport {PileFab} from \"@1754-factory/tinlake/src/borrower/fabs/pile.sol\";\nimport {TitleFab} from \"@1754-factory/tinlake/src/borrower/fabs/title.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TinlakeDeployer is Ownable {}\n"
    },
    "@1754-factory/tinlake/src/root.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\ninterface AuthLike {\n    function rely(address) external;\n\n    function deny(address) external;\n}\n\ninterface DependLike {\n    function depend(bytes32, address) external;\n}\n\ninterface BorrowerDeployerLike {\n    function feed() external returns (address);\n\n    function shelf() external returns (address);\n\n    function title() external returns (address);\n}\n\ninterface LenderDeployerLike {\n    function assessor() external returns (address);\n\n    function reserve() external returns (address);\n\n    function poolAdmin() external returns (address);\n}\n\ninterface AdapterDeployerLike {\n    function mgr() external returns (address);\n\n    function wireAdapter() external;\n}\n\ninterface PoolAdminLike {\n    function setAdminLevel(address, uint256) external;\n}\n\ncontract TinlakeRoot is Auth {\n    BorrowerDeployerLike public borrowerDeployer;\n    LenderDeployerLike public lenderDeployer;\n    AdapterDeployerLike public adapterDeployer;\n\n    bool public deployed;\n    address public deployUsr;\n    address public immutable governance;\n\n    address public oracle;\n    address[] public level1Admins;\n    address public level3Admin;\n\n    constructor(address deployUsr_, address governance_) {\n        deployUsr = deployUsr_;\n        governance = governance_;\n        wards[governance_] = 1;\n        emit Rely(governance_);\n    }\n\n    // --- Prepare ---\n    // Sets the two deployer dependencies. This needs to be called by the deployUsr\n    function prepare(\n        address lender_,\n        address borrower_,\n        address adapter_,\n        address oracle_,\n        address[] memory level1Admins_,\n        address level3Admin_\n    ) public {\n        require(deployUsr == msg.sender);\n\n        borrowerDeployer = BorrowerDeployerLike(borrower_);\n        lenderDeployer = LenderDeployerLike(lender_);\n        if (adapter_ != address(0))\n            adapterDeployer = AdapterDeployerLike(adapter_);\n        oracle = oracle_;\n        level1Admins = level1Admins_;\n        level3Admin = level3Admin_;\n\n        deployUsr = address(0); // disallow the deploy user to call this more than once.\n    }\n\n    function prepare(\n        address lender_,\n        address borrower_,\n        address adapter_\n    ) public {\n        prepare(\n            lender_,\n            borrower_,\n            adapter_,\n            address(0),\n            new address[](0),\n            address(0)\n        );\n    }\n\n    function prepare(address lender_, address borrower_) public {\n        prepare(\n            lender_,\n            borrower_,\n            address(0),\n            address(0),\n            new address[](0),\n            address(0)\n        );\n    }\n\n    // --- Deploy ---\n    // After going through the deploy process on the lender and borrower method, this method is called to connect\n    // lender and borrower contracts.\n    function deploy() public {\n        require(\n            address(borrowerDeployer) != address(0) &&\n                address(lenderDeployer) != address(0) &&\n                deployed == false\n        );\n        deployed = true;\n        address reserve_ = lenderDeployer.reserve();\n        address shelf_ = borrowerDeployer.shelf();\n        address assessor_ = lenderDeployer.assessor();\n\n        // Borrower depends\n        DependLike(borrowerDeployer.shelf()).depend(\"reserve\", reserve_);\n        DependLike(borrowerDeployer.shelf()).depend(\"assessor\", assessor_);\n\n        // Lender depends\n        address navFeed = borrowerDeployer.feed();\n\n        // shelf can deposit and payout from reserve\n        AuthLike(reserve_).rely(shelf_);\n        DependLike(assessor_).depend(\"navFeed\", navFeed);\n\n        // Lender wards\n        if (oracle != address(0)) AuthLike(navFeed).rely(oracle);\n\n        DependLike(lenderDeployer.poolAdmin()).depend(\"navFeed\", navFeed);\n        AuthLike(navFeed).rely(lenderDeployer.poolAdmin());\n\n        PoolAdminLike poolAdmin = PoolAdminLike(lenderDeployer.poolAdmin());\n        poolAdmin.setAdminLevel(governance, 3);\n        poolAdmin.setAdminLevel(level3Admin, 3);\n\n        for (uint256 i = 0; i < level1Admins.length; i++) {\n            poolAdmin.setAdminLevel(level1Admins[i], 1);\n        }\n    }\n\n    // --- Governance Functions ---\n    // `relyContract` & `denyContract` can be called by any ward on the TinlakeRoot\n    // contract to make an arbitrary address a ward on any contract the TinlakeRoot\n    // is a ward on.\n    function relyContract(address target, address usr) public auth {\n        AuthLike(target).rely(usr);\n    }\n\n    function denyContract(address target, address usr) public auth {\n        AuthLike(target).deny(usr);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/deployer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {ReserveFabLike, AssessorFabLike, TrancheFabLike, CoordinatorFabLike, OperatorFabLike, MemberlistFabLike, RestrictedTokenFabLike, PoolAdminFabLike, ClerkFabLike} from \"./fabs/interfaces.sol\";\n\nimport {FixedPoint} from \"./../fixed_point.sol\";\n\ninterface DependLike {\n    function depend(bytes32, address) external;\n}\n\ninterface AuthLike {\n    function rely(address) external;\n\n    function deny(address) external;\n}\n\ninterface MemberlistLike {\n    function updateMember(address, uint256) external;\n}\n\ninterface FileLike {\n    function file(bytes32 name, uint256 value) external;\n}\n\ninterface PoolAdminLike {\n    function rely(address) external;\n}\n\ncontract LenderDeployer is FixedPoint {\n    address public immutable root;\n    address public immutable currency;\n    address public immutable memberAdmin;\n\n    // factory contracts\n    TrancheFabLike public immutable trancheFab;\n    ReserveFabLike public immutable reserveFab;\n    AssessorFabLike public immutable assessorFab;\n    CoordinatorFabLike public immutable coordinatorFab;\n    OperatorFabLike public immutable operatorFab;\n    MemberlistFabLike public immutable memberlistFab;\n    RestrictedTokenFabLike public immutable restrictedTokenFab;\n    PoolAdminFabLike public immutable poolAdminFab;\n\n    // lender state variables\n    Fixed27 public minSeniorRatio;\n    Fixed27 public maxSeniorRatio;\n    uint256 public maxReserve;\n    uint256 public challengeTime;\n    Fixed27 public seniorInterestRate;\n\n    // contract addresses\n    address public adapterDeployer;\n    address public assessor;\n    address public poolAdmin;\n    address public seniorTranche;\n    address public juniorTranche;\n    address public seniorOperator;\n    address public juniorOperator;\n    address public reserve;\n    address public coordinator;\n\n    address public seniorToken;\n    address public juniorToken;\n\n    // token names\n    string public seniorName;\n    string public seniorSymbol;\n    string public juniorName;\n    string public juniorSymbol;\n    // restricted token member list\n    address public seniorMemberlist;\n    address public juniorMemberlist;\n\n    address public deployer;\n    bool public wired;\n\n    constructor(\n        address root_,\n        address currency_,\n        address trancheFab_,\n        address memberlistFab_,\n        address restrictedtokenFab_,\n        address reserveFab_,\n        address assessorFab_,\n        address coordinatorFab_,\n        address operatorFab_,\n        address poolAdminFab_,\n        address memberAdmin_,\n        address adapterDeployer_\n    ) {\n        deployer = msg.sender;\n        root = root_;\n        currency = currency_;\n        memberAdmin = memberAdmin_;\n        adapterDeployer = adapterDeployer_;\n\n        trancheFab = TrancheFabLike(trancheFab_);\n        memberlistFab = MemberlistFabLike(memberlistFab_);\n        restrictedTokenFab = RestrictedTokenFabLike(restrictedtokenFab_);\n        reserveFab = ReserveFabLike(reserveFab_);\n        assessorFab = AssessorFabLike(assessorFab_);\n        poolAdminFab = PoolAdminFabLike(poolAdminFab_);\n        coordinatorFab = CoordinatorFabLike(coordinatorFab_);\n        operatorFab = OperatorFabLike(operatorFab_);\n    }\n\n    function init(\n        uint256 minSeniorRatio_,\n        uint256 maxSeniorRatio_,\n        uint256 maxReserve_,\n        uint256 challengeTime_,\n        uint256 seniorInterestRate_,\n        string memory seniorName_,\n        string memory seniorSymbol_,\n        string memory juniorName_,\n        string memory juniorSymbol_\n    ) public {\n        require(msg.sender == deployer);\n        challengeTime = challengeTime_;\n        minSeniorRatio = Fixed27(minSeniorRatio_);\n        maxSeniorRatio = Fixed27(maxSeniorRatio_);\n        maxReserve = maxReserve_;\n        seniorInterestRate = Fixed27(seniorInterestRate_);\n\n        // token names\n        seniorName = seniorName_;\n        seniorSymbol = seniorSymbol_;\n        juniorName = juniorName_;\n        juniorSymbol = juniorSymbol_;\n\n        deployer = address(1);\n    }\n\n    function deployJunior() public {\n        require(juniorTranche == address(0) && deployer == address(1));\n        juniorToken = restrictedTokenFab.newRestrictedToken(\n            juniorSymbol,\n            juniorName\n        );\n        juniorTranche = trancheFab.newTranche(currency, juniorToken);\n        juniorMemberlist = memberlistFab.newMemberlist();\n        juniorOperator = operatorFab.newOperator(juniorTranche);\n        AuthLike(juniorMemberlist).rely(root);\n        AuthLike(juniorToken).rely(root);\n        AuthLike(juniorToken).rely(juniorTranche);\n        AuthLike(juniorOperator).rely(root);\n        AuthLike(juniorTranche).rely(root);\n    }\n\n    function deploySenior() public {\n        require(seniorTranche == address(0) && deployer == address(1));\n        seniorToken = restrictedTokenFab.newRestrictedToken(\n            seniorSymbol,\n            seniorName\n        );\n        seniorTranche = trancheFab.newTranche(currency, seniorToken);\n        seniorMemberlist = memberlistFab.newMemberlist();\n        seniorOperator = operatorFab.newOperator(seniorTranche);\n        AuthLike(seniorMemberlist).rely(root);\n        AuthLike(seniorToken).rely(root);\n        AuthLike(seniorToken).rely(seniorTranche);\n        AuthLike(seniorOperator).rely(root);\n        AuthLike(seniorTranche).rely(root);\n\n        if (adapterDeployer != address(0)) {\n            AuthLike(seniorTranche).rely(adapterDeployer);\n            AuthLike(seniorMemberlist).rely(adapterDeployer);\n        }\n    }\n\n    function deployReserve() public {\n        require(reserve == address(0) && deployer == address(1));\n        reserve = reserveFab.newReserve(currency);\n        AuthLike(reserve).rely(root);\n        if (adapterDeployer != address(0))\n            AuthLike(reserve).rely(adapterDeployer);\n    }\n\n    function deployAssessor() public {\n        require(assessor == address(0) && deployer == address(1));\n        assessor = assessorFab.newAssessor();\n        AuthLike(assessor).rely(root);\n        if (adapterDeployer != address(0))\n            AuthLike(assessor).rely(adapterDeployer);\n    }\n\n    function deployPoolAdmin() public {\n        require(poolAdmin == address(0) && deployer == address(1));\n        poolAdmin = poolAdminFab.newPoolAdmin();\n        PoolAdminLike(poolAdmin).rely(root);\n        if (adapterDeployer != address(0))\n            PoolAdminLike(poolAdmin).rely(adapterDeployer);\n    }\n\n    function deployCoordinator() public {\n        require(coordinator == address(0) && deployer == address(1));\n        coordinator = coordinatorFab.newCoordinator(challengeTime);\n        AuthLike(coordinator).rely(root);\n    }\n\n    function deploy() public virtual {\n        require(\n            coordinator != address(0) &&\n                assessor != address(0) &&\n                reserve != address(0) &&\n                seniorTranche != address(0)\n        );\n\n        require(!wired, \"lender contracts already wired\"); // make sure lender contracts only wired once\n        wired = true;\n\n        // required depends\n        // reserve\n        AuthLike(reserve).rely(seniorTranche);\n        AuthLike(reserve).rely(juniorTranche);\n        AuthLike(reserve).rely(coordinator);\n        AuthLike(reserve).rely(assessor);\n\n        // tranches\n        DependLike(seniorTranche).depend(\"reserve\", reserve);\n        DependLike(juniorTranche).depend(\"reserve\", reserve);\n        AuthLike(seniorTranche).rely(coordinator);\n        AuthLike(juniorTranche).rely(coordinator);\n        AuthLike(seniorTranche).rely(seniorOperator);\n        AuthLike(juniorTranche).rely(juniorOperator);\n\n        // coordinator implements epoch ticker interface\n        DependLike(seniorTranche).depend(\"coordinator\", coordinator);\n        DependLike(juniorTranche).depend(\"coordinator\", coordinator);\n\n        //restricted token\n        DependLike(seniorToken).depend(\"memberlist\", seniorMemberlist);\n        DependLike(juniorToken).depend(\"memberlist\", juniorMemberlist);\n\n        //allow tinlake contracts to hold drop/tin tokens\n        MemberlistLike(juniorMemberlist).updateMember(\n            juniorTranche,\n            type(uint256).max\n        );\n        MemberlistLike(seniorMemberlist).updateMember(\n            seniorTranche,\n            type(uint256).max\n        );\n\n        // operator\n        DependLike(seniorOperator).depend(\"tranche\", seniorTranche);\n        DependLike(juniorOperator).depend(\"tranche\", juniorTranche);\n        DependLike(seniorOperator).depend(\"token\", seniorToken);\n        DependLike(juniorOperator).depend(\"token\", juniorToken);\n\n        // coordinator\n        DependLike(coordinator).depend(\"seniorTranche\", seniorTranche);\n        DependLike(coordinator).depend(\"juniorTranche\", juniorTranche);\n        DependLike(coordinator).depend(\"assessor\", assessor);\n\n        AuthLike(coordinator).rely(poolAdmin);\n\n        // assessor\n        DependLike(assessor).depend(\"seniorTranche\", seniorTranche);\n        DependLike(assessor).depend(\"juniorTranche\", juniorTranche);\n        DependLike(assessor).depend(\"reserve\", reserve);\n\n        AuthLike(assessor).rely(coordinator);\n        AuthLike(assessor).rely(reserve);\n        AuthLike(assessor).rely(poolAdmin);\n\n        // poolAdmin\n        DependLike(poolAdmin).depend(\"assessor\", assessor);\n        DependLike(poolAdmin).depend(\"juniorMemberlist\", juniorMemberlist);\n        DependLike(poolAdmin).depend(\"seniorMemberlist\", seniorMemberlist);\n        DependLike(poolAdmin).depend(\"coordinator\", coordinator);\n\n        AuthLike(juniorMemberlist).rely(poolAdmin);\n        AuthLike(seniorMemberlist).rely(poolAdmin);\n\n        if (memberAdmin != address(0))\n            AuthLike(juniorMemberlist).rely(memberAdmin);\n        if (memberAdmin != address(0))\n            AuthLike(seniorMemberlist).rely(memberAdmin);\n\n        FileLike(assessor).file(\"seniorInterestRate\", seniorInterestRate.value);\n        FileLike(assessor).file(\"maxReserve\", maxReserve);\n        FileLike(assessor).file(\"maxSeniorRatio\", maxSeniorRatio.value);\n        FileLike(assessor).file(\"minSeniorRatio\", minSeniorRatio.value);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/borrower/deployer.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {ShelfFabLike, PileFabLike, TitleFabLike} from \"./fabs/interfaces.sol\";\nimport {FixedPoint} from \"./../fixed_point.sol\";\n\ninterface DependLike {\n    function depend(bytes32, address) external;\n}\n\ninterface AuthLike {\n    function rely(address) external;\n\n    function deny(address) external;\n}\n\ninterface NAVFeedLike {\n    function init() external;\n}\n\ninterface FeedFabLike {\n    function newFeed() external returns (address);\n}\n\ninterface FileLike {\n    function file(bytes32 name, uint256 value) external;\n}\n\ncontract BorrowerDeployer is FixedPoint {\n    address public immutable root;\n\n    TitleFabLike public immutable titlefab;\n    ShelfFabLike public immutable shelffab;\n    PileFabLike public immutable pilefab;\n    FeedFabLike public immutable feedFab;\n\n    address public title;\n    address public shelf;\n    address public pile;\n    address public immutable currency;\n    address public feed;\n\n    string public titleName;\n    string public titleSymbol;\n    Fixed27 public discountRate;\n\n    address constant ZERO = address(0);\n    bool public wired;\n\n    constructor(\n        address root_,\n        address titlefab_,\n        address shelffab_,\n        address pilefab_,\n        address feedFab_,\n        address currency_,\n        string memory titleName_,\n        string memory titleSymbol_,\n        uint256 discountRate_\n    ) {\n        root = root_;\n\n        titlefab = TitleFabLike(titlefab_);\n        shelffab = ShelfFabLike(shelffab_);\n\n        pilefab = PileFabLike(pilefab_);\n        feedFab = FeedFabLike(feedFab_);\n\n        currency = currency_;\n\n        titleName = titleName_;\n        titleSymbol = titleSymbol_;\n        discountRate = Fixed27(discountRate_);\n    }\n\n    function deployPile() public {\n        require(pile == ZERO);\n        pile = pilefab.newPile();\n        AuthLike(pile).rely(root);\n    }\n\n    function deployTitle() public {\n        require(title == ZERO);\n        title = titlefab.newTitle(titleName, titleSymbol);\n        AuthLike(title).rely(root);\n    }\n\n    function deployShelf() public {\n        require(shelf == ZERO && title != ZERO && pile != ZERO && feed != ZERO);\n        shelf = shelffab.newShelf(\n            currency,\n            address(title),\n            address(pile),\n            address(feed)\n        );\n        AuthLike(shelf).rely(root);\n    }\n\n    function deployFeed() public {\n        require(feed == ZERO);\n        feed = feedFab.newFeed();\n        AuthLike(feed).rely(root);\n    }\n\n    function deploy(bool initNAVFeed) public {\n        // ensures all required deploy methods were called\n        require(shelf != ZERO);\n        require(!wired, \"borrower contracts already wired\"); // make sure borrower contracts only wired once\n        wired = true;\n\n        // shelf allowed to call\n        AuthLike(pile).rely(shelf);\n\n        DependLike(feed).depend(\"shelf\", address(shelf));\n        DependLike(feed).depend(\"pile\", address(pile));\n\n        // allow nftFeed to update rate groups\n        AuthLike(pile).rely(feed);\n\n        DependLike(shelf).depend(\"subscriber\", address(feed));\n\n        AuthLike(feed).rely(shelf);\n        AuthLike(title).rely(shelf);\n\n        FileLike(feed).file(\"discountRate\", discountRate.value);\n\n        if (initNAVFeed) {\n            NAVFeedLike(feed).init();\n        }\n    }\n\n    function deploy() public {\n        deploy(false);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/fabs/tranche.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Tranche} from \"./../tranche.sol\";\n\ninterface TrancheFabLike {\n    function newTranche(address, address) external returns (address);\n}\n\ncontract TrancheFab {\n    function newTranche(address currency, address restrictedToken)\n        public\n        returns (address token)\n    {\n        Tranche tranche = new Tranche(currency, restrictedToken);\n\n        tranche.rely(msg.sender);\n        tranche.deny(address(this));\n\n        return (address(tranche));\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/fabs/memberlist.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Memberlist} from \"./../token/memberlist.sol\";\n\ninterface MemberlistFabLike {\n    function newMemberlist() external returns (address);\n}\n\ncontract MemberlistFab {\n    function newMemberlist() public returns (address memberList) {\n        Memberlist memberlist = new Memberlist();\n\n        memberlist.rely(msg.sender);\n        memberlist.deny(address(this));\n\n        return (address(memberlist));\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/fabs/reserve.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Reserve} from \"./../reserve.sol\";\n\ninterface ReserveFabLike {\n    function newReserve(address) external returns (address);\n}\n\ncontract ReserveFab {\n    function newReserve(address currency) public returns (address) {\n        Reserve reserve = new Reserve(currency);\n        reserve.rely(msg.sender);\n        reserve.deny(address(this));\n        return address(reserve);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/fabs/assessor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Assessor} from \"./../assessor.sol\";\n\ninterface AssessorFabLike {\n    function newAssessor() external returns (address);\n}\n\ncontract AssessorFab {\n    function newAssessor() public returns (address) {\n        Assessor assessor = new Assessor();\n        assessor.rely(msg.sender);\n        assessor.deny(address(this));\n        return address(assessor);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/fabs/pooladmin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {PoolAdmin} from \"./../admin/pool.sol\";\n\ncontract PoolAdminFab {\n    function newPoolAdmin() public returns (address) {\n        PoolAdmin poolAdmin = new PoolAdmin();\n\n        poolAdmin.rely(msg.sender);\n        poolAdmin.deny(address(this));\n\n        return address(poolAdmin);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/fabs/coordinator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {EpochCoordinator} from \"./../coordinator.sol\";\nimport \"@1754-factory/packages/src/tokens/erc20.sol\";\nimport \"../coordinator.sol\";\n\ninterface CoordinatorFabLike {\n    function newCoordinator(uint256) external returns (address);\n}\n\ncontract CoordinatorFab {\n    function newCoordinator(uint256 challengeTime) public returns (address) {\n        EpochCoordinator coordinator = new EpochCoordinator(challengeTime);\n        coordinator.rely(msg.sender);\n        coordinator.deny(address(this));\n        return address(coordinator);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/fabs/operator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\nimport {Operator} from \"./../operator.sol\";\n\ninterface OperatorFabLike {\n    function newOperator(address) external returns (address);\n}\n\ncontract OperatorFab {\n    function newOperator(address tranche) public returns (address) {\n        Operator operator = new Operator(tranche);\n        operator.rely(msg.sender);\n        operator.deny(address(this));\n        return address(operator);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/borrower/fabs/shelf.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Shelf} from \"./../shelf.sol\";\n\ncontract ShelfFab {\n    function newShelf(\n        address tkn_,\n        address title_,\n        address debt_,\n        address ceiling_\n    ) public returns (address) {\n        Shelf shelf = new Shelf(tkn_, title_, debt_, ceiling_);\n        shelf.rely(msg.sender);\n        shelf.deny(address(this));\n        return address(shelf);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/borrower/fabs/pile.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Pile} from \"./../pile.sol\";\n\ncontract PileFab {\n    function newPile() public returns (address) {\n        Pile pile = new Pile();\n        pile.rely(msg.sender);\n        pile.deny(address(this));\n        return address(pile);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/borrower/fabs/title.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Title} from \"@1754-factory/packages/src/ownership/title.sol\";\n\ncontract TitleFab {\n    function newTitle(string memory name, string memory symbol)\n        public\n        returns (address)\n    {\n        Title title = new Title(name, symbol);\n        title.rely(msg.sender);\n        title.deny(address(this));\n        return address(title);\n    }\n}\n"
    },
    "@1754-factory/packages/src/auth/auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\npragma solidity ^0.8.10;\n\ncontract Auth {\n    mapping (address => uint256) public wards;\n    \n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"not-authorized\");\n        _;\n    }\n\n}"
    },
    "@1754-factory/tinlake/src/lender/fabs/interfaces.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\ninterface ReserveFabLike {\n    function newReserve(address) external returns (address);\n}\n\ninterface AssessorFabLike {\n    function newAssessor() external returns (address);\n}\n\ninterface TrancheFabLike {\n    function newTranche(address, address) external returns (address);\n}\n\ninterface CoordinatorFabLike {\n    function newCoordinator(uint256) external returns (address);\n}\n\ninterface OperatorFabLike {\n    function newOperator(address) external returns (address);\n}\n\ninterface MemberlistFabLike {\n    function newMemberlist() external returns (address);\n}\n\ninterface RestrictedTokenFabLike {\n    function newRestrictedToken(string calldata, string calldata)\n        external\n        returns (address);\n}\n\ninterface PoolAdminFabLike {\n    function newPoolAdmin() external returns (address);\n}\n\ninterface ClerkFabLike {\n    function newClerk(address, address) external returns (address);\n}\n\ninterface TinlakeManagerFabLike {\n    function newTinlakeManager(\n        address,\n        address,\n        address,\n        address,\n        address,\n        address,\n        address,\n        address\n    ) external returns (address);\n}\n"
    },
    "@1754-factory/tinlake/src/fixed_point.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nabstract contract FixedPoint {\n    struct Fixed27 {\n        uint256 value;\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/borrower/fabs/interfaces.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\ninterface NAVFeedFabLike {\n    function newFeed() external returns (address);\n}\n\ninterface TitleFabLike {\n    function newTitle(string calldata, string calldata)\n        external\n        returns (address);\n}\n\ninterface PileFabLike {\n    function newPile() external returns (address);\n}\n\ninterface ShelfFabLike {\n    function newShelf(\n        address,\n        address,\n        address,\n        address\n    ) external returns (address);\n}\n"
    },
    "@1754-factory/tinlake/src/lender/tranche.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/auth/auth.sol\";\nimport \"@1754-factory/packages/src/math/math.sol\";\nimport \"./../fixed_point.sol\";\n\ninterface ERC20Like {\n    function balanceOf(address) external view returns (uint256);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function mint(address, uint256) external;\n\n    function burn(address, uint256) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function approve(address usr, uint256 amount) external;\n}\n\ninterface ReserveLike {\n    function deposit(uint256 amount) external;\n\n    function payout(uint256 amount) external;\n\n    function totalBalanceAvailable() external returns (uint256);\n}\n\ninterface CoordinatorLike {\n    function currentEpoch() external view returns (uint256);\n\n    function lastEpochExecuted() external view returns (uint256);\n}\n\ncontract Tranche is Math, Auth, FixedPoint {\n    mapping(uint256 => Epoch) public epochs;\n\n    struct Epoch {\n        // denominated in 10^27\n        // percentage ONE == 100%\n        uint256 redeemFulfillment;\n        // denominated in 10^27\n        // percentage ONE == 100%\n        uint256 supplyFulfillment;\n        // tokenPrice after end of epoch\n        uint256 tokenPrice;\n    }\n\n    struct UserOrder {\n        uint256 orderedInEpoch;\n        uint256 supplyCurrencyAmount;\n        uint256 redeemTokenAmount;\n    }\n\n    mapping(address => UserOrder) public users;\n\n    uint256 public totalSupply;\n    uint256 public totalRedeem;\n\n    ERC20Like public currency;\n    ERC20Like public token;\n    ReserveLike public reserve;\n    CoordinatorLike public coordinator;\n\n    // additional requested currency if the reserve could not fulfill a tranche request\n    uint256 public requestedCurrency;\n\n    bool public waitingForUpdate = false;\n\n    event Depend(bytes32 indexed contractName, address addr);\n    event Mint(address indexed usr, uint256 amount);\n    event Burn(address indexed usr, uint256 amount);\n    event AuthTransfer(address indexed erc20, address usr, uint256 amount);\n\n    modifier orderAllowed(address usr) {\n        require(\n            (users[usr].supplyCurrencyAmount == 0 &&\n                users[usr].redeemTokenAmount == 0) ||\n                users[usr].orderedInEpoch == coordinator.currentEpoch(),\n            \"disburse required\"\n        );\n        _;\n    }\n\n    constructor(address currency_, address token_) {\n        token = ERC20Like(token_);\n        currency = ERC20Like(currency_);\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function balance() external view returns (uint256) {\n        return currency.balanceOf(address(this));\n    }\n\n    function tokenSupply() external view returns (uint256) {\n        return token.totalSupply();\n    }\n\n    function depend(bytes32 contractName, address addr) public auth {\n        if (contractName == \"token\") {\n            token = ERC20Like(addr);\n        } else if (contractName == \"currency\") {\n            currency = ERC20Like(addr);\n        } else if (contractName == \"reserve\") {\n            reserve = ReserveLike(addr);\n        } else if (contractName == \"coordinator\") {\n            coordinator = CoordinatorLike(addr);\n        } else revert();\n        emit Depend(contractName, addr);\n    }\n\n    // supplyOrder function can be used to place or revoke an supply\n    function supplyOrder(address usr, uint256 newSupplyAmount)\n        public\n        auth\n        orderAllowed(usr)\n    {\n        users[usr].orderedInEpoch = coordinator.currentEpoch();\n\n        uint256 currentSupplyAmount = users[usr].supplyCurrencyAmount;\n\n        users[usr].supplyCurrencyAmount = newSupplyAmount;\n\n        totalSupply = safeAdd(\n            safeTotalSub(totalSupply, currentSupplyAmount),\n            newSupplyAmount\n        );\n\n        uint256 delta;\n        if (newSupplyAmount > currentSupplyAmount) {\n            delta = safeSub(newSupplyAmount, currentSupplyAmount);\n            require(\n                currency.transferFrom(usr, address(this), delta),\n                \"currency-transfer-failed\"\n            );\n            return;\n        }\n        delta = safeSub(currentSupplyAmount, newSupplyAmount);\n        if (delta > 0) {\n            _safeTransfer(currency, usr, delta);\n        }\n    }\n\n    // redeemOrder function can be used to place or revoke a redeem\n    function redeemOrder(address usr, uint256 newRedeemAmount)\n        public\n        auth\n        orderAllowed(usr)\n    {\n        users[usr].orderedInEpoch = coordinator.currentEpoch();\n\n        uint256 currentRedeemAmount = users[usr].redeemTokenAmount;\n        users[usr].redeemTokenAmount = newRedeemAmount;\n        totalRedeem = safeAdd(\n            safeTotalSub(totalRedeem, currentRedeemAmount),\n            newRedeemAmount\n        );\n\n        uint256 delta;\n        if (newRedeemAmount > currentRedeemAmount) {\n            delta = safeSub(newRedeemAmount, currentRedeemAmount);\n            require(\n                token.transferFrom(usr, address(this), delta),\n                \"token-transfer-failed\"\n            );\n            return;\n        }\n\n        delta = safeSub(currentRedeemAmount, newRedeemAmount);\n        if (delta > 0) {\n            _safeTransfer(token, usr, delta);\n        }\n    }\n\n    function calcDisburse(address usr)\n        public\n        view\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        )\n    {\n        return calcDisburse(usr, coordinator.lastEpochExecuted());\n    }\n\n    //  calculates the current disburse of a user starting from the ordered epoch until endEpoch\n    function calcDisburse(address usr, uint256 endEpoch)\n        public\n        view\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        )\n    {\n        uint256 epochIdx = users[usr].orderedInEpoch;\n        uint256 lastEpochExecuted = coordinator.lastEpochExecuted();\n\n        // no disburse possible in this epoch\n        if (users[usr].orderedInEpoch == coordinator.currentEpoch()) {\n            return (\n                payoutCurrencyAmount,\n                payoutTokenAmount,\n                users[usr].supplyCurrencyAmount,\n                users[usr].redeemTokenAmount\n            );\n        }\n\n        if (endEpoch > lastEpochExecuted) {\n            // it is only possible to disburse epochs which are already over\n            endEpoch = lastEpochExecuted;\n        }\n\n        remainingSupplyCurrency = users[usr].supplyCurrencyAmount;\n        remainingRedeemToken = users[usr].redeemTokenAmount;\n        uint256 amount = 0;\n\n        // calculates disburse amounts as long as remaining tokens or currency is left or the end epoch is reached\n        while (\n            epochIdx <= endEpoch &&\n            (remainingSupplyCurrency != 0 || remainingRedeemToken != 0)\n        ) {\n            if (remainingSupplyCurrency != 0) {\n                amount = rmul(\n                    remainingSupplyCurrency,\n                    epochs[epochIdx].supplyFulfillment\n                );\n                // supply currency payout in token\n                if (amount != 0) {\n                    payoutTokenAmount = safeAdd(\n                        payoutTokenAmount,\n                        safeDiv(\n                            safeMul(amount, ONE),\n                            epochs[epochIdx].tokenPrice\n                        )\n                    );\n                    remainingSupplyCurrency = safeSub(\n                        remainingSupplyCurrency,\n                        amount\n                    );\n                }\n            }\n\n            if (remainingRedeemToken != 0) {\n                amount = rmul(\n                    remainingRedeemToken,\n                    epochs[epochIdx].redeemFulfillment\n                );\n                // redeem token payout in currency\n                if (amount != 0) {\n                    payoutCurrencyAmount = safeAdd(\n                        payoutCurrencyAmount,\n                        rmul(amount, epochs[epochIdx].tokenPrice)\n                    );\n                    remainingRedeemToken = safeSub(\n                        remainingRedeemToken,\n                        amount\n                    );\n                }\n            }\n            epochIdx = safeAdd(epochIdx, 1);\n        }\n\n        return (\n            payoutCurrencyAmount,\n            payoutTokenAmount,\n            remainingSupplyCurrency,\n            remainingRedeemToken\n        );\n    }\n\n    // the disburse function can be used after an epoch is over to receive currency and tokens\n    function disburse(address usr)\n        public\n        auth\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        )\n    {\n        return disburse(usr, coordinator.lastEpochExecuted());\n    }\n\n    function _safeTransfer(\n        ERC20Like erc20,\n        address usr,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 max = erc20.balanceOf(address(this));\n        if (amount > max) {\n            amount = max;\n        }\n        require(erc20.transfer(usr, amount), \"token-transfer-failed\");\n        return amount;\n    }\n\n    // the disburse function can be used after an epoch is over to receive currency and tokens\n    function disburse(address usr, uint256 endEpoch)\n        public\n        auth\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        )\n    {\n        require(\n            users[usr].orderedInEpoch <= coordinator.lastEpochExecuted(),\n            \"epoch-not-executed-yet\"\n        );\n\n        uint256 lastEpochExecuted = coordinator.lastEpochExecuted();\n\n        if (endEpoch > lastEpochExecuted) {\n            // it is only possible to disburse epochs which are already over\n            endEpoch = lastEpochExecuted;\n        }\n\n        (\n            payoutCurrencyAmount,\n            payoutTokenAmount,\n            remainingSupplyCurrency,\n            remainingRedeemToken\n        ) = calcDisburse(usr, endEpoch);\n        users[usr].supplyCurrencyAmount = remainingSupplyCurrency;\n        users[usr].redeemTokenAmount = remainingRedeemToken;\n        // if lastEpochExecuted is disbursed, orderInEpoch is at the current epoch again\n        // which allows to change the order. This is only possible if all previous epochs are disbursed\n        users[usr].orderedInEpoch = safeAdd(endEpoch, 1);\n\n        if (payoutCurrencyAmount > 0) {\n            payoutCurrencyAmount = _safeTransfer(\n                currency,\n                usr,\n                payoutCurrencyAmount\n            );\n        }\n\n        if (payoutTokenAmount > 0) {\n            payoutTokenAmount = _safeTransfer(token, usr, payoutTokenAmount);\n        }\n        return (\n            payoutCurrencyAmount,\n            payoutTokenAmount,\n            remainingSupplyCurrency,\n            remainingRedeemToken\n        );\n    }\n\n    // called by epoch coordinator in epoch execute method\n    function epochUpdate(\n        uint256 epochID,\n        uint256 supplyFulfillment_,\n        uint256 redeemFulfillment_,\n        uint256 tokenPrice_,\n        uint256 epochSupplyOrderCurrency,\n        uint256 epochRedeemOrderCurrency\n    ) public auth {\n        require(waitingForUpdate == true);\n        waitingForUpdate = false;\n\n        epochs[epochID].supplyFulfillment = supplyFulfillment_;\n        epochs[epochID].redeemFulfillment = redeemFulfillment_;\n        epochs[epochID].tokenPrice = tokenPrice_;\n\n        // currency needs to be converted to tokenAmount with current token price\n        uint256 redeemInToken = 0;\n        uint256 supplyInToken = 0;\n        if (tokenPrice_ > 0) {\n            supplyInToken = rdiv(epochSupplyOrderCurrency, tokenPrice_);\n            redeemInToken = safeDiv(\n                safeMul(epochRedeemOrderCurrency, ONE),\n                tokenPrice_\n            );\n        }\n\n        // calculates the delta between supply and redeem for currency and deposit or get them from the reserve\n        adjustCurrencyBalance(\n            epochID,\n            epochSupplyOrderCurrency,\n            epochRedeemOrderCurrency\n        );\n        // calculates the delta between supply and redeem for tokens and burn or mint them\n        adjustTokenBalance(epochID, supplyInToken, redeemInToken);\n\n        // the unfulfilled orders (1-fulfillment) is automatically ordered\n        totalSupply = safeAdd(\n            safeTotalSub(totalSupply, epochSupplyOrderCurrency),\n            rmul(\n                epochSupplyOrderCurrency,\n                safeSub(ONE, epochs[epochID].supplyFulfillment)\n            )\n        );\n        totalRedeem = safeAdd(\n            safeTotalSub(totalRedeem, redeemInToken),\n            rmul(redeemInToken, safeSub(ONE, epochs[epochID].redeemFulfillment))\n        );\n    }\n\n    function closeEpoch()\n        public\n        auth\n        returns (uint256 totalSupplyCurrency_, uint256 totalRedeemToken_)\n    {\n        require(waitingForUpdate == false);\n        waitingForUpdate = true;\n        return (totalSupply, totalRedeem);\n    }\n\n    function safeBurn(uint256 tokenAmount) internal {\n        uint256 max = token.balanceOf(address(this));\n        if (tokenAmount > max) {\n            tokenAmount = max;\n        }\n        token.burn(address(this), tokenAmount);\n        emit Burn(address(this), tokenAmount);\n    }\n\n    function safePayout(uint256 currencyAmount)\n        internal\n        returns (uint256 payoutAmount)\n    {\n        uint256 max = reserve.totalBalanceAvailable();\n\n        if (currencyAmount > max) {\n            // currently reserve can't fulfill the entire request\n            currencyAmount = max;\n        }\n        reserve.payout(currencyAmount);\n        return currencyAmount;\n    }\n\n    function payoutRequestedCurrency() public {\n        if (requestedCurrency > 0) {\n            uint256 payoutAmount = safePayout(requestedCurrency);\n            requestedCurrency = safeSub(requestedCurrency, payoutAmount);\n        }\n    }\n\n    // adjust token balance after epoch execution -> min/burn tokens\n    function adjustTokenBalance(\n        uint256 epochID,\n        uint256 epochSupplyToken,\n        uint256 epochRedeemToken\n    ) internal {\n        // mint token amount for supply\n\n        uint256 mintAmount = 0;\n        if (epochs[epochID].tokenPrice > 0) {\n            mintAmount = rmul(\n                epochSupplyToken,\n                epochs[epochID].supplyFulfillment\n            );\n        }\n\n        // burn token amount for redeem\n        uint256 burnAmount = rmul(\n            epochRedeemToken,\n            epochs[epochID].redeemFulfillment\n        );\n        // burn tokens that are not needed for disbursement\n        uint256 diff;\n        if (burnAmount > mintAmount) {\n            diff = safeSub(burnAmount, mintAmount);\n            safeBurn(diff);\n            return;\n        }\n        // mint tokens that are required for disbursement\n        diff = safeSub(mintAmount, burnAmount);\n        if (diff > 0) {\n            token.mint(address(this), diff);\n        }\n    }\n\n    // additional minting of tokens produces a dilution of all token holders\n    // interface is required for adapters\n    function mint(address usr, uint256 amount) public auth {\n        token.mint(usr, amount);\n        emit Mint(usr, amount);\n    }\n\n    // adjust currency balance after epoch execution -> receive/send currency from/to reserve\n    function adjustCurrencyBalance(\n        uint256 epochID,\n        uint256 epochSupply,\n        uint256 epochRedeem\n    ) internal {\n        // currency that was supplied in this epoch\n        uint256 currencySupplied = rmul(\n            epochSupply,\n            epochs[epochID].supplyFulfillment\n        );\n        // currency required for redemption\n        uint256 currencyRequired = rmul(\n            epochRedeem,\n            epochs[epochID].redeemFulfillment\n        );\n\n        uint256 diff;\n        if (currencySupplied > currencyRequired) {\n            // send surplus currency to reserve\n            diff = safeSub(currencySupplied, currencyRequired);\n            currency.approve(address(reserve), diff);\n            reserve.deposit(diff);\n            return;\n        }\n        diff = safeSub(currencyRequired, currencySupplied);\n        if (diff > 0) {\n            // get missing currency from reserve\n            uint256 payoutAmount = safePayout(diff);\n            if (payoutAmount < diff) {\n                // reserve couldn't fulfill the entire request\n                requestedCurrency = safeAdd(\n                    requestedCurrency,\n                    safeSub(diff, payoutAmount)\n                );\n            }\n        }\n    }\n\n    // recovery transfer can be used by governance to recover funds if tokens are stuck\n    function authTransfer(\n        address erc20,\n        address usr,\n        uint256 amount\n    ) public auth {\n        ERC20Like(erc20).transfer(usr, amount);\n        emit AuthTransfer(erc20, usr, amount);\n    }\n\n    // due to rounding in token & currency conversions currency & token balances might be off by 1 wei with the totalSupply/totalRedeem amounts.\n    // in order to prevent an underflow error, 0 is returned when amount to be subtracted is bigger then the total value.\n    function safeTotalSub(uint256 total, uint256 amount)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (total < amount) {\n            return 0;\n        }\n        return safeSub(total, amount);\n    }\n}\n"
    },
    "@1754-factory/packages/src/math/math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\npragma solidity ^0.8.10;\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}"
    },
    "@1754-factory/tinlake/src/lender/token/memberlist.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/math/math.sol\";\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\ncontract Memberlist is Math, Auth {\n    uint256 constant minimumDelay = 7 days;\n\n    // -- Members--\n    mapping(address => uint256) public members;\n\n    function updateMember(address usr, uint256 validUntil) public auth {\n        require((safeAdd(block.timestamp, minimumDelay)) < validUntil);\n        members[usr] = validUntil;\n    }\n\n    function updateMembers(address[] memory users, uint256 validUntil)\n        public\n        auth\n    {\n        for (uint256 i = 0; i < users.length; i++) {\n            updateMember(users[i], validUntil);\n        }\n    }\n\n    constructor() {\n        wards[msg.sender] = 1;\n    }\n\n    function member(address usr) public view {\n        require((members[usr] >= block.timestamp), \"not-allowed-to-hold-token\");\n    }\n\n    function hasMember(address usr) public view returns (bool) {\n        if (members[usr] >= block.timestamp) {\n            return true;\n        }\n        return false;\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/reserve.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/math/math.sol\";\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\ninterface ERC20Like {\n    function balanceOf(address) external view returns (uint256);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function mint(address, uint256) external;\n\n    function burn(address, uint256) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function approve(address, uint256) external;\n}\n\ninterface LendingAdapter {\n    function remainingCredit() external view returns (uint256);\n\n    function draw(uint256 amount) external;\n\n    function wipe(uint256 amount) external;\n\n    function debt() external returns (uint256);\n\n    function activated() external view returns (bool);\n}\n\n// The reserve keeps track of the currency and the bookkeeping\n// of the total balance\ncontract Reserve is Math, Auth {\n    ERC20Like public currency;\n\n    // additional currency from lending adapters\n    // for deactivating set to address(0)\n    LendingAdapter public lending;\n\n    // currency available for borrowing new loans\n    uint256 public currencyAvailable;\n\n    // address or contract which holds the currency\n    // by default it is address(this)\n    address pot;\n\n    // total currency in the reserve\n    uint256 public balance_;\n\n    event File(bytes32 indexed what, uint256 amount);\n    event Depend(bytes32 contractName, address addr);\n\n    constructor(address currency_) {\n        currency = ERC20Like(currency_);\n        pot = address(this);\n        currency.approve(pot, type(uint256).max);\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function file(bytes32 what, uint256 amount) public auth {\n        if (what == \"currencyAvailable\") {\n            currencyAvailable = amount;\n        } else revert();\n        emit File(what, amount);\n    }\n\n    function depend(bytes32 contractName, address addr) public auth {\n        if (contractName == \"currency\") {\n            currency = ERC20Like(addr);\n            if (pot == address(this)) {\n                currency.approve(pot, type(uint256).max);\n            }\n        } else if (contractName == \"pot\") {\n            pot = addr;\n        } else if (contractName == \"lending\") {\n            lending = LendingAdapter(addr);\n        } else revert();\n        emit Depend(contractName, addr);\n    }\n\n    // returns the amount of currency currently in the reserve\n    function totalBalance() public view returns (uint256) {\n        return balance_;\n    }\n\n    // return the amount of currency and the available currency from the lending adapter\n    function totalBalanceAvailable() public view returns (uint256) {\n        if (address(lending) == address(0)) {\n            return balance_;\n        }\n\n        return safeAdd(balance_, lending.remainingCredit());\n    }\n\n    // deposits currency in the the reserve\n    function deposit(uint256 currencyAmount) public auth {\n        if (currencyAmount == 0) return;\n        _deposit(msg.sender, currencyAmount);\n    }\n\n    // hard deposit guarantees that the currency stays in the reserve\n    function hardDeposit(uint256 currencyAmount) public auth {\n        _depositAction(msg.sender, currencyAmount);\n    }\n\n    function _depositAction(address usr, uint256 currencyAmount) internal {\n        require(\n            currency.transferFrom(usr, pot, currencyAmount),\n            \"reserve-deposit-failed\"\n        );\n        balance_ = safeAdd(balance_, currencyAmount);\n    }\n\n    function _deposit(address usr, uint256 currencyAmount) internal {\n        _depositAction(usr, currencyAmount);\n        if (\n            address(lending) != address(0) &&\n            lending.debt() > 0 &&\n            lending.activated()\n        ) {\n            uint256 wipeAmount = lending.debt();\n            uint256 available = balance_;\n            if (available < wipeAmount) {\n                wipeAmount = available;\n            }\n            lending.wipe(wipeAmount);\n        }\n    }\n\n    // remove currency from the reserve\n    function payout(uint256 currencyAmount) public auth {\n        if (currencyAmount == 0) return;\n        _payout(msg.sender, currencyAmount);\n    }\n\n    function _payoutAction(address usr, uint256 currencyAmount) internal {\n        require(\n            currency.transferFrom(pot, usr, currencyAmount),\n            \"reserve-payout-failed\"\n        );\n        balance_ = safeSub(balance_, currencyAmount);\n    }\n\n    // hard payout guarantees that the currency stays in the reserve\n    function hardPayout(uint256 currencyAmount) public auth {\n        _payoutAction(msg.sender, currencyAmount);\n    }\n\n    function _payout(address usr, uint256 currencyAmount) internal {\n        uint256 reserveBalance = balance_;\n        if (\n            currencyAmount > reserveBalance &&\n            address(lending) != address(0) &&\n            lending.activated()\n        ) {\n            uint256 drawAmount = safeSub(currencyAmount, reserveBalance);\n            uint256 left = lending.remainingCredit();\n            if (drawAmount > left) {\n                drawAmount = left;\n            }\n\n            lending.draw(drawAmount);\n        }\n\n        _payoutAction(usr, currencyAmount);\n    }\n\n    // payout currency for loans not all funds\n    // in the reserve are compulsory available for loans in the current epoch\n    function payoutForLoans(uint256 currencyAmount) public auth {\n        require(\n            currencyAvailable >= currencyAmount,\n            \"not-enough-currency-reserve\"\n        );\n\n        currencyAvailable = safeSub(currencyAvailable, currencyAmount);\n        _payout(msg.sender, currencyAmount);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/assessor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/auth/auth.sol\";\nimport \"@1754-factory/packages/src/math/interest.sol\";\nimport \"./definitions.sol\";\n\ninterface NAVFeedLike {\n    function calcUpdateNAV() external returns (uint256);\n\n    function latestNAV() external view returns (uint256);\n\n    function currentNAV() external view returns (uint256);\n\n    function lastNAVUpdate() external view returns (uint256);\n}\n\ninterface TrancheLike {\n    function tokenSupply() external view returns (uint256);\n}\n\ninterface ReserveLike {\n    function totalBalance() external view returns (uint256);\n\n    function file(bytes32 what, uint256 currencyAmount) external;\n\n    function currencyAvailable() external view returns (uint256);\n}\n\ninterface LendingAdapter {\n    function remainingCredit() external view returns (uint256);\n\n    function juniorStake() external view returns (uint256);\n\n    function calcOvercollAmount(uint256 amount) external view returns (uint256);\n\n    function stabilityFee() external view returns (uint256);\n\n    function debt() external view returns (uint256);\n}\n\ncontract Assessor is Definitions, Auth, Interest {\n    // senior ratio from the last epoch executed\n    Fixed27 public seniorRatio;\n\n    // the seniorAsset value is stored in two variables\n    // seniorDebt is the interest bearing amount for senior\n    uint256 public seniorDebt_;\n    // senior balance is the rest which is not used as interest\n    // bearing amount\n    uint256 public seniorBalance_;\n\n    // interest rate per second for senior tranche\n    Fixed27 public seniorInterestRate;\n\n    // last time the senior interest has been updated\n    uint256 public lastUpdateSeniorInterest;\n\n    Fixed27 public maxSeniorRatio;\n    Fixed27 public minSeniorRatio;\n\n    uint256 public maxReserve;\n\n    uint256 public creditBufferTime = 1 days;\n    uint256 public maxStaleNAV = 1 days;\n\n    TrancheLike public seniorTranche;\n    TrancheLike public juniorTranche;\n    NAVFeedLike public navFeed;\n    ReserveLike public reserve;\n    LendingAdapter public lending;\n\n    uint256 public constant supplyTolerance = 5;\n\n    event Depend(bytes32 indexed contractName, address addr);\n    event File(bytes32 indexed name, uint256 value);\n\n    constructor() {\n        seniorInterestRate.value = ONE;\n        lastUpdateSeniorInterest = block.timestamp;\n        seniorRatio.value = 0;\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function depend(bytes32 contractName, address addr) public auth {\n        if (contractName == \"navFeed\") {\n            navFeed = NAVFeedLike(addr);\n        } else if (contractName == \"seniorTranche\") {\n            seniorTranche = TrancheLike(addr);\n        } else if (contractName == \"juniorTranche\") {\n            juniorTranche = TrancheLike(addr);\n        } else if (contractName == \"reserve\") {\n            reserve = ReserveLike(addr);\n        } else if (contractName == \"lending\") {\n            lending = LendingAdapter(addr);\n        } else revert();\n        emit Depend(contractName, addr);\n    }\n\n    function file(bytes32 name, uint256 value) public auth {\n        if (name == \"seniorInterestRate\") {\n            dripSeniorDebt();\n            seniorInterestRate = Fixed27(value);\n        } else if (name == \"maxReserve\") {\n            maxReserve = value;\n        } else if (name == \"maxSeniorRatio\") {\n            require(value > minSeniorRatio.value, \"value-too-small\");\n            maxSeniorRatio = Fixed27(value);\n        } else if (name == \"minSeniorRatio\") {\n            require(value < maxSeniorRatio.value, \"value-too-big\");\n            minSeniorRatio = Fixed27(value);\n        } else if (name == \"creditBufferTime\") {\n            creditBufferTime = value;\n        } else if (name == \"maxStaleNAV\") {\n            maxStaleNAV = value;\n        } else {\n            revert(\"unknown-variable\");\n        }\n        emit File(name, value);\n    }\n\n    function reBalance() public {\n        reBalance(calcExpectedSeniorAsset(seniorBalance_, dripSeniorDebt()));\n    }\n\n    function reBalance(uint256 seniorAsset_) internal {\n        // re-balancing according to new ratio\n        // we use the approximated NAV here because because during the submission period\n        // new loans might have been repaid in the meanwhile which are not considered in the epochNAV\n        uint256 nav_ = getNAV();\n        uint256 reserve_ = reserve.totalBalance();\n\n        uint256 seniorRatio_ = calcSeniorRatio(seniorAsset_, nav_, reserve_);\n\n        // in that case the entire juniorAsset is lost\n        // the senior would own everything that' left\n        if (seniorRatio_ > ONE) {\n            seniorRatio_ = ONE;\n        }\n\n        seniorDebt_ = rmul(nav_, seniorRatio_);\n        if (seniorDebt_ > seniorAsset_) {\n            seniorDebt_ = seniorAsset_;\n            seniorBalance_ = 0;\n        } else {\n            seniorBalance_ = safeSub(seniorAsset_, seniorDebt_);\n        }\n        seniorRatio = Fixed27(seniorRatio_);\n    }\n\n    function changeSeniorAsset(uint256 seniorSupply, uint256 seniorRedeem)\n        external\n        auth\n    {\n        reBalance(\n            calcExpectedSeniorAsset(\n                seniorRedeem,\n                seniorSupply,\n                seniorBalance_,\n                dripSeniorDebt()\n            )\n        );\n    }\n\n    function seniorRatioBounds()\n        public\n        view\n        returns (uint256 minSeniorRatio_, uint256 maxSeniorRatio_)\n    {\n        return (minSeniorRatio.value, maxSeniorRatio.value);\n    }\n\n    function calcUpdateNAV() external returns (uint256) {\n        return navFeed.calcUpdateNAV();\n    }\n\n    function calcSeniorTokenPrice() external view returns (uint256) {\n        return calcSeniorTokenPrice(getNAV(), reserve.totalBalance());\n    }\n\n    function calcSeniorTokenPrice(uint256 nav_, uint256)\n        public\n        view\n        returns (uint256)\n    {\n        return _calcSeniorTokenPrice(nav_, reserve.totalBalance());\n    }\n\n    function calcJuniorTokenPrice() external view returns (uint256) {\n        return _calcJuniorTokenPrice(getNAV(), reserve.totalBalance());\n    }\n\n    function calcJuniorTokenPrice(uint256 nav_, uint256)\n        public\n        view\n        returns (uint256)\n    {\n        return _calcJuniorTokenPrice(nav_, reserve.totalBalance());\n    }\n\n    function calcTokenPrices() external view returns (uint256, uint256) {\n        uint256 epochNAV = getNAV();\n        uint256 epochReserve = reserve.totalBalance();\n        return calcTokenPrices(epochNAV, epochReserve);\n    }\n\n    function calcTokenPrices(uint256 epochNAV, uint256 epochReserve)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return (\n            _calcJuniorTokenPrice(epochNAV, epochReserve),\n            _calcSeniorTokenPrice(epochNAV, epochReserve)\n        );\n    }\n\n    function _calcSeniorTokenPrice(uint256 nav_, uint256 reserve_)\n        internal\n        view\n        returns (uint256)\n    {\n        // the coordinator interface will pass the reserveAvailable\n\n        if (\n            (nav_ == 0 && reserve_ == 0) ||\n            seniorTranche.tokenSupply() <= supplyTolerance\n        ) {\n            // we are using a tolerance of 2 here, as there can be minimal supply leftovers after all redemptions due to rounding\n            // initial token price at start 1.00\n            return ONE;\n        }\n\n        uint256 totalAssets = safeAdd(nav_, reserve_);\n        uint256 seniorAssetValue = calcExpectedSeniorAsset(\n            seniorDebt(),\n            seniorBalance_\n        );\n\n        if (totalAssets < seniorAssetValue) {\n            seniorAssetValue = totalAssets;\n        }\n        return rdiv(seniorAssetValue, seniorTranche.tokenSupply());\n    }\n\n    function _calcJuniorTokenPrice(uint256 nav_, uint256 reserve_)\n        internal\n        view\n        returns (uint256)\n    {\n        if (\n            (nav_ == 0 && reserve_ == 0) ||\n            juniorTranche.tokenSupply() <= supplyTolerance\n        ) {\n            // we are using a tolerance of 2 here, as there can be minimal supply leftovers after all redemptions due to rounding\n            // initial token price at start 1.00\n            return ONE;\n        }\n        // reserve includes creditline from maker\n        uint256 totalAssets = safeAdd(nav_, reserve_);\n\n        // includes creditline from mkr\n        uint256 seniorAssetValue = calcExpectedSeniorAsset(\n            seniorDebt(),\n            seniorBalance_\n        );\n\n        if (totalAssets < seniorAssetValue) {\n            return 0;\n        }\n\n        // the junior tranche only needs to pay for the mkr over-collateralization if\n        // the mkr vault is liquidated, if that is true juniorStake=0\n        uint256 juniorStake = 0;\n        if (address(lending) != address(0)) {\n            juniorStake = lending.juniorStake();\n        }\n\n        return\n            rdiv(\n                safeAdd(safeSub(totalAssets, seniorAssetValue), juniorStake),\n                juniorTranche.tokenSupply()\n            );\n    }\n\n    function dripSeniorDebt() public returns (uint256) {\n        seniorDebt_ = seniorDebt();\n        lastUpdateSeniorInterest = block.timestamp;\n        return seniorDebt_;\n    }\n\n    function seniorDebt() public view returns (uint256) {\n        if (block.timestamp >= lastUpdateSeniorInterest) {\n            return\n                chargeInterest(\n                    seniorDebt_,\n                    seniorInterestRate.value,\n                    lastUpdateSeniorInterest\n                );\n        }\n        return seniorDebt_;\n    }\n\n    function seniorBalance() public view returns (uint256) {\n        return safeAdd(seniorBalance_, remainingOvercollCredit());\n    }\n\n    function effectiveSeniorBalance() public view returns (uint256) {\n        return seniorBalance_;\n    }\n\n    function effectiveTotalBalance() public view returns (uint256) {\n        return reserve.totalBalance();\n    }\n\n    function totalBalance() public view returns (uint256) {\n        return safeAdd(reserve.totalBalance(), remainingCredit());\n    }\n\n    // returns the current NAV\n    function getNAV() public view returns (uint256) {\n        if (block.timestamp >= navFeed.lastNAVUpdate() + maxStaleNAV) {\n            return navFeed.currentNAV();\n        }\n\n        return navFeed.latestNAV();\n    }\n\n    // changes the total amount available for borrowing loans\n    function changeBorrowAmountEpoch(uint256 currencyAmount) public auth {\n        reserve.file(\"currencyAvailable\", currencyAmount);\n    }\n\n    function borrowAmountEpoch() public view returns (uint256) {\n        return reserve.currencyAvailable();\n    }\n\n    // returns the current junior ratio protection in the Tinlake\n    // juniorRatio is denominated in RAY (10^27)\n    function calcJuniorRatio() public view returns (uint256) {\n        uint256 seniorAsset = safeAdd(seniorDebt(), seniorBalance_);\n        uint256 assets = safeAdd(getNAV(), reserve.totalBalance());\n\n        if (seniorAsset == 0 && assets == 0) {\n            return 0;\n        }\n\n        if (seniorAsset == 0 && assets > 0) {\n            return ONE;\n        }\n\n        if (seniorAsset > assets) {\n            return 0;\n        }\n\n        return safeSub(ONE, rdiv(seniorAsset, assets));\n    }\n\n    // returns the remainingCredit plus a buffer for the interest increase\n    function remainingCredit() public view returns (uint256) {\n        if (address(lending) == address(0)) {\n            return 0;\n        }\n\n        // over the time the remainingCredit will decrease because of the accumulated debt interest\n        // therefore a buffer is reduced from the  remainingCredit to prevent the usage of currency which is not available\n        uint256 debt = lending.debt();\n        uint256 stabilityBuffer = safeSub(\n            rmul(rpow(lending.stabilityFee(), creditBufferTime, ONE), debt),\n            debt\n        );\n        uint256 remainingCredit_ = lending.remainingCredit();\n        if (remainingCredit_ > stabilityBuffer) {\n            return safeSub(remainingCredit_, stabilityBuffer);\n        }\n\n        return 0;\n    }\n\n    function remainingOvercollCredit() public view returns (uint256) {\n        if (address(lending) == address(0)) {\n            return 0;\n        }\n\n        return lending.calcOvercollAmount(remainingCredit());\n    }\n}\n"
    },
    "@1754-factory/packages/src/math/interest.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) 2018 Rain <rainbreak@riseup.net> and Centrifuge, referencing MakerDAO dss => https://github.com/makerdao/dss/blob/master/src/pot.sol\npragma solidity ^0.8.10;\n\nimport \"./math.sol\";\n\ncontract Interest is Math {\n    // @notice This function provides compounding in seconds\n    // @param chi Accumulated interest rate over time\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10ˆ27)\n    // @param lastUpdated When the interest rate was last updated\n    // @param pie Total sum of all amounts accumulating under one interest rate, divided by that rate\n    // @return The new accumulated rate, as well as the difference between the debt calculated with the old and new accumulated rates.\n    function compounding(uint chi, uint ratePerSecond, uint lastUpdated, uint pie) public view returns (uint, uint) {\n        require(block.timestamp >= lastUpdated, \"tinlake-math/invalid-timestamp\");\n        require(chi != 0);\n        // instead of a interestBearingAmount we use a accumulated interest rate index (chi)\n        uint updatedChi = _chargeInterest(chi ,ratePerSecond, lastUpdated, block.timestamp);\n        return (updatedChi, safeSub(rmul(updatedChi, pie), rmul(chi, pie)));\n    }\n\n    // @notice This function charge interest on a interestBearingAmount\n    // @param interestBearingAmount is the interest bearing amount\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10ˆ27)\n    // @param lastUpdated last time the interest has been charged\n    // @return interestBearingAmount + interest\n    function chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated) public view returns (uint) {\n        if (block.timestamp >= lastUpdated) {\n            interestBearingAmount = _chargeInterest(interestBearingAmount, ratePerSecond, lastUpdated, block.timestamp);\n        }\n        return interestBearingAmount;\n    }\n\n    function _chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated, uint current) internal pure returns (uint) {\n        return rmul(rpow(ratePerSecond, current - lastUpdated, ONE), interestBearingAmount);\n    }\n\n\n    // convert pie to debt/savings amount\n    function toAmount(uint chi, uint pie) public pure returns (uint) {\n        return rmul(pie, chi);\n    }\n\n    // convert debt/savings amount to pie\n    function toPie(uint chi, uint amount) public pure returns (uint) {\n        return rdivup(amount, chi);\n    }\n\n    function rpow(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                let xx := mul(x, x)\n                if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                let xxRound := add(xx, half)\n                if lt(xxRound, xx) { revert(0,0) }\n                x := div(xxRound, base)\n                if mod(n,2) {\n                    let zx := mul(z, x)\n                    if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                    let zxRound := add(zx, half)\n                    if lt(zxRound, zx) { revert(0,0) }\n                    z := div(zxRound, base)\n                }\n            }\n            }\n        }\n    }\n}"
    },
    "@1754-factory/tinlake/src/lender/definitions.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/math/math.sol\";\nimport \"./../fixed_point.sol\";\n\n// contract without a state which defines the relevant formulars for the assessor\ncontract Definitions is FixedPoint, Math {\n    function calcExpectedSeniorAsset(\n        uint256 _seniorDebt,\n        uint256 _seniorBalance\n    ) public pure returns (uint256) {\n        return safeAdd(_seniorDebt, _seniorBalance);\n    }\n\n    // calculates the senior ratio\n    function calcSeniorRatio(\n        uint256 seniorAsset,\n        uint256 nav,\n        uint256 reserve_\n    ) public pure returns (uint256) {\n        // note: NAV + reserve == seniorAsset + juniorAsset (loop invariant: always true)\n        // if expectedSeniorAsset is passed ratio can be greater than ONE\n        uint256 assets = calcAssets(nav, reserve_);\n        if (assets == 0) {\n            return 0;\n        }\n\n        return rdiv(seniorAsset, assets);\n    }\n\n    function calcSeniorRatio(\n        uint256 seniorRedeem,\n        uint256 seniorSupply,\n        uint256 currSeniorAsset,\n        uint256 newReserve,\n        uint256 nav\n    ) public pure returns (uint256 seniorRatio) {\n        return\n            calcSeniorRatio(\n                calcSeniorAssetValue(\n                    seniorRedeem,\n                    seniorSupply,\n                    currSeniorAsset,\n                    newReserve,\n                    nav\n                ),\n                nav,\n                newReserve\n            );\n    }\n\n    // calculates the net wealth in the system\n    // NAV for ongoing loans and currency in reserve\n    function calcAssets(uint256 NAV, uint256 reserve_)\n        public\n        pure\n        returns (uint256)\n    {\n        return safeAdd(NAV, reserve_);\n    }\n\n    // calculates a new senior asset value based on senior redeem and senior supply\n    function calcSeniorAssetValue(\n        uint256 seniorRedeem,\n        uint256 seniorSupply,\n        uint256 currSeniorAsset,\n        uint256 reserve_,\n        uint256 nav_\n    ) public pure returns (uint256 seniorAsset) {\n        seniorAsset = safeSub(\n            safeAdd(currSeniorAsset, seniorSupply),\n            seniorRedeem\n        );\n        uint256 assets = calcAssets(nav_, reserve_);\n        if (seniorAsset > assets) {\n            seniorAsset = assets;\n        }\n\n        return seniorAsset;\n    }\n\n    // expected senior return if no losses occur\n    function calcExpectedSeniorAsset(\n        uint256 seniorRedeem,\n        uint256 seniorSupply,\n        uint256 seniorBalance_,\n        uint256 seniorDebt_\n    ) public pure returns (uint256) {\n        return\n            safeSub(\n                safeAdd(safeAdd(seniorDebt_, seniorBalance_), seniorSupply),\n                seniorRedeem\n            );\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/admin/pool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\ninterface AssessorLike {\n    function file(bytes32 name, uint256 value) external;\n}\n\ninterface LendingAdapterLike {\n    function raise(uint256 amount) external;\n\n    function sink(uint256 amount) external;\n\n    function heal() external;\n\n    function file(bytes32 what, uint256 value) external;\n}\n\ninterface FeedLike {\n    function overrideWriteOff(uint256 loan, uint256 writeOffGroupIndex_)\n        external;\n\n    function file(\n        bytes32 name,\n        uint256 risk_,\n        uint256 thresholdRatio_,\n        uint256 ceilingRatio_,\n        uint256 rate_,\n        uint256 recoveryRatePD_\n    ) external;\n\n    function file(\n        bytes32 name,\n        uint256 rate_,\n        uint256 writeOffPercentage_,\n        uint256 overdueDays_\n    ) external;\n\n    function file(bytes32 name, uint256 value) external;\n\n    function file(\n        bytes32 name,\n        bytes32 nftID_,\n        uint256 maturityDate_\n    ) external;\n\n    function update(bytes32 nftID_, uint256 value) external;\n\n    function update(\n        bytes32 nftID_,\n        uint256 value,\n        uint256 risk_\n    ) external;\n}\n\ninterface MemberlistLike {\n    function updateMember(address usr, uint256 validUntil) external;\n\n    function updateMembers(address[] calldata users, uint256 validUntil)\n        external;\n}\n\ninterface CoordinatorLike {\n    function file(bytes32 name, uint256 value) external;\n\n    function file(bytes32 name, bool value) external;\n\n    function poolClosing() external view returns (bool);\n}\n\n// Wrapper contract for various pool management tasks.\ncontract PoolAdmin {\n    AssessorLike public assessor;\n    LendingAdapterLike public lending;\n    FeedLike public navFeed;\n    MemberlistLike public seniorMemberlist;\n    MemberlistLike public juniorMemberlist;\n    CoordinatorLike public coordinator;\n\n    bool public live = true;\n\n    mapping(address => uint256) public admin_level;\n\n    uint256 public constant LEVEL_1 = 1;\n    uint256 public constant LEVEL_2 = 2;\n    uint256 public constant LEVEL_3 = 3;\n\n    modifier level1() {\n        require(admin_level[msg.sender] >= LEVEL_1 && live);\n        _;\n    }\n    modifier level2() {\n        require(admin_level[msg.sender] >= LEVEL_2 && live);\n        _;\n    }\n    modifier level3() {\n        require(admin_level[msg.sender] == LEVEL_3 && live);\n        _;\n    }\n\n    constructor() {\n        admin_level[msg.sender] = LEVEL_3;\n        emit SetAdminLevel(msg.sender, LEVEL_3);\n    }\n\n    // --- Liquidity Management, authorized by level 1 admins ---\n    event SetMaxReserve(uint256 value);\n    event RaiseCreditline(uint256 amount);\n    event SinkCreditline(uint256 amount);\n    event HealCreditline();\n    event UpdateSeniorMember(address indexed usr, uint256 validUntil);\n    event UpdateSeniorMembers(address[] indexed users, uint256 validUntil);\n    event UpdateJuniorMember(address indexed usr, uint256 validUntil);\n    event UpdateJuniorMembers(address[] indexed users, uint256 validUntil);\n\n    // Manage max reserve\n    function setMaxReserve(uint256 value) public level1 {\n        assessor.file(\"maxReserve\", value);\n        emit SetMaxReserve(value);\n    }\n\n    // Manage creditline\n    function raiseCreditline(uint256 amount) public level1 {\n        lending.raise(amount);\n        emit RaiseCreditline(amount);\n    }\n\n    function sinkCreditline(uint256 amount) public level1 {\n        lending.sink(amount);\n        emit SinkCreditline(amount);\n    }\n\n    function healCreditline() public level1 {\n        lending.heal();\n        emit HealCreditline();\n    }\n\n    function setMaxReserveAndRaiseCreditline(\n        uint256 newMaxReserve,\n        uint256 creditlineRaise\n    ) public level1 {\n        setMaxReserve(newMaxReserve);\n        raiseCreditline(creditlineRaise);\n    }\n\n    function setMaxReserveAndSinkCreditline(\n        uint256 newMaxReserve,\n        uint256 creditlineSink\n    ) public level1 {\n        setMaxReserve(newMaxReserve);\n        sinkCreditline(creditlineSink);\n    }\n\n    // Manage memberlists\n    function updateSeniorMember(address usr, uint256 validUntil) public level1 {\n        seniorMemberlist.updateMember(usr, validUntil);\n        emit UpdateSeniorMember(usr, validUntil);\n    }\n\n    function updateSeniorMembers(address[] memory users, uint256 validUntil)\n        public\n        level1\n    {\n        seniorMemberlist.updateMembers(users, validUntil);\n        emit UpdateSeniorMembers(users, validUntil);\n    }\n\n    function updateJuniorMember(address usr, uint256 validUntil) public level1 {\n        juniorMemberlist.updateMember(usr, validUntil);\n        emit UpdateJuniorMember(usr, validUntil);\n    }\n\n    function updateJuniorMembers(address[] memory users, uint256 validUntil)\n        public\n        level1\n    {\n        juniorMemberlist.updateMembers(users, validUntil);\n        emit UpdateJuniorMembers(users, validUntil);\n    }\n\n    // --- Risk Management, authorized by level 2 admins ---\n    event OverrideWriteOff(uint256 loan, uint256 writeOffGroupIndex);\n    event AddRiskGroup(\n        uint256 risk_,\n        uint256 thresholdRatio_,\n        uint256 ceilingRatio_,\n        uint256 rate_,\n        uint256 recoveryRatePD_\n    );\n    event AddRiskGroups(\n        uint256[] risks_,\n        uint256[] thresholdRatios_,\n        uint256[] ceilingRatios_,\n        uint256[] rates_\n    );\n    event AddWriteOffGroup(\n        uint256 rate_,\n        uint256 writeOffPercentage_,\n        uint256 overdueDays_\n    );\n    event SetMatBuffer(uint256 value);\n    event UpdateNFTValue(bytes32 nftID_, uint256 value);\n    event UpdateNFTValueRisk(bytes32 nftID_, uint256 value, uint256 risk_);\n    event UpdateNFTMaturityDate(bytes32 nftID_, uint256 maturityDate_);\n\n    function overrideWriteOff(uint256 loan, uint256 writeOffGroupIndex_)\n        public\n        level2\n    {\n        navFeed.overrideWriteOff(loan, writeOffGroupIndex_);\n        emit OverrideWriteOff(loan, writeOffGroupIndex_);\n    }\n\n    function addRiskGroup(\n        uint256 risk_,\n        uint256 thresholdRatio_,\n        uint256 ceilingRatio_,\n        uint256 rate_,\n        uint256 recoveryRatePD_\n    ) public level2 {\n        navFeed.file(\n            \"riskGroup\",\n            risk_,\n            thresholdRatio_,\n            ceilingRatio_,\n            rate_,\n            recoveryRatePD_\n        );\n        emit AddRiskGroup(\n            risk_,\n            thresholdRatio_,\n            ceilingRatio_,\n            rate_,\n            recoveryRatePD_\n        );\n    }\n\n    function addRiskGroups(\n        uint256[] memory risks_,\n        uint256[] memory thresholdRatios_,\n        uint256[] memory ceilingRatios_,\n        uint256[] memory rates_,\n        uint256[] memory recoveryRatePDs_\n    ) public level2 {\n        require(\n            risks_.length == thresholdRatios_.length &&\n                thresholdRatios_.length == ceilingRatios_.length &&\n                ceilingRatios_.length == rates_.length &&\n                rates_.length == recoveryRatePDs_.length,\n            \"non-matching-arguments\"\n        );\n        for (uint256 i = 0; i < risks_.length; i++) {\n            addRiskGroup(\n                risks_[i],\n                thresholdRatios_[i],\n                ceilingRatios_[i],\n                rates_[i],\n                recoveryRatePDs_[i]\n            );\n        }\n    }\n\n    function addWriteOffGroup(\n        uint256 rate_,\n        uint256 writeOffPercentage_,\n        uint256 overdueDays_\n    ) public level2 {\n        navFeed.file(\"writeOffGroup\", rate_, writeOffPercentage_, overdueDays_);\n        emit AddWriteOffGroup(rate_, writeOffPercentage_, overdueDays_);\n    }\n\n    function addWriteOffGroups(\n        uint256[] memory rates_,\n        uint256[] memory writeOffPercentages_,\n        uint256[] memory overdueDays_\n    ) public level2 {\n        require(\n            rates_.length == writeOffPercentages_.length &&\n                writeOffPercentages_.length == overdueDays_.length,\n            \"non-matching-arguments\"\n        );\n        for (uint256 i = 0; i < rates_.length; i++) {\n            addWriteOffGroup(\n                rates_[i],\n                writeOffPercentages_[i],\n                overdueDays_[i]\n            );\n        }\n    }\n\n    function setMatBuffer(uint256 value) public level3 {\n        lending.file(\"buffer\", value);\n        emit SetMatBuffer(value);\n    }\n\n    function setMaxAutoHeal(uint256 value) public level3 {\n        lending.file(\"autoHealMax\", value);\n    }\n\n    function updateNFTValue(bytes32 nftID_, uint256 value) public level2 {\n        navFeed.update(nftID_, value);\n        emit UpdateNFTValue(nftID_, value);\n    }\n\n    function updateNFTValueRisk(\n        bytes32 nftID_,\n        uint256 value,\n        uint256 risk_\n    ) public level2 {\n        navFeed.update(nftID_, value, risk_);\n        emit UpdateNFTValueRisk(nftID_, value, risk_);\n    }\n\n    function updateNFTMaturityDate(bytes32 nftID_, uint256 maturityDate_)\n        public\n        level2\n    {\n        navFeed.file(\"maturityDate\", nftID_, maturityDate_);\n        emit UpdateNFTMaturityDate(nftID_, maturityDate_);\n    }\n\n    // --- Pool Governance, authorized by level 3 admins ---\n    event File(bytes32 indexed what, bool indexed data);\n    event SetSeniorInterestRate(uint256 value);\n    event SetDiscountRate(uint256 value);\n    event SetMinimumEpochTime(uint256 value);\n    event SetChallengeTime(uint256 value);\n    event SetMinSeniorRatio(uint256 value);\n    event SetMaxSeniorRatio(uint256 value);\n    event SetEpochScoringWeights(\n        uint256 weightSeniorRedeem,\n        uint256 weightJuniorRedeem,\n        uint256 weightJuniorSupply,\n        uint256 weightSeniorSupply\n    );\n    event ClosePool();\n    event UnclosePool();\n    event SetAdminLevel(address indexed usr, uint256 indexed level);\n    event Depend(bytes32 indexed contractname, address addr);\n\n    function setSeniorInterestRate(uint256 value) public level3 {\n        assessor.file(\"seniorInterestRate\", value);\n        emit SetSeniorInterestRate(value);\n    }\n\n    function setDiscountRate(uint256 value) public level3 {\n        navFeed.file(\"discountRate\", value);\n        emit SetDiscountRate(value);\n    }\n\n    function setMinimumEpochTime(uint256 value) public level3 {\n        coordinator.file(\"minimumEpochTime\", value);\n        emit SetMinimumEpochTime(value);\n    }\n\n    function setChallengeTime(uint256 value) public level3 {\n        coordinator.file(\"challengeTime\", value);\n        emit SetChallengeTime(value);\n    }\n\n    function setMinSeniorRatio(uint256 value) public level3 {\n        assessor.file(\"minSeniorRatio\", value);\n        emit SetMinSeniorRatio(value);\n    }\n\n    function setMaxSeniorRatio(uint256 value) public level3 {\n        assessor.file(\"maxSeniorRatio\", value);\n        emit SetMaxSeniorRatio(value);\n    }\n\n    function setEpochScoringWeights(\n        uint256 weightSeniorRedeem,\n        uint256 weightJuniorRedeem,\n        uint256 weightJuniorSupply,\n        uint256 weightSeniorSupply\n    ) public level3 {\n        coordinator.file(\"weightSeniorRedeem\", weightSeniorRedeem);\n        coordinator.file(\"weightJuniorRedeem\", weightJuniorRedeem);\n        coordinator.file(\"weightJuniorSupply\", weightJuniorSupply);\n        coordinator.file(\"weightSeniorSupply\", weightSeniorSupply);\n        emit SetEpochScoringWeights(\n            weightSeniorRedeem,\n            weightJuniorRedeem,\n            weightJuniorSupply,\n            weightSeniorSupply\n        );\n    }\n\n    function closePool() public level3 {\n        require(coordinator.poolClosing() == false, \"already-closed\");\n        coordinator.file(\"poolClosing\", true);\n        emit ClosePool();\n    }\n\n    function unclosePool() public level3 {\n        require(coordinator.poolClosing() == true, \"not-yet-closed\");\n        coordinator.file(\"poolClosing\", false);\n        emit UnclosePool();\n    }\n\n    modifier canSetAdminlevel(uint256 level) {\n        require(level >= 0 && level <= LEVEL_3);\n        if (level == 0) require(admin_level[msg.sender] == LEVEL_3);\n        if (level == LEVEL_1) require(admin_level[msg.sender] >= LEVEL_2);\n        if (level == LEVEL_2 || level == LEVEL_3)\n            require(admin_level[msg.sender] == LEVEL_3);\n        _;\n    }\n\n    function setAdminLevel(address usr, uint256 level)\n        public\n        canSetAdminlevel(level)\n    {\n        admin_level[usr] = level;\n        emit SetAdminLevel(usr, level);\n    }\n\n    // Aliases so the root contract can use its relyContract/denyContract methods\n    function rely(address usr) public level3 {\n        setAdminLevel(usr, 3);\n    }\n\n    function deny(address usr) public level3 {\n        setAdminLevel(usr, 0);\n    }\n\n    function depend(bytes32 contractName, address addr) public level3 {\n        if (contractName == \"assessor\") {\n            assessor = AssessorLike(addr);\n        } else if (contractName == \"lending\") {\n            lending = LendingAdapterLike(addr);\n        } else if (contractName == \"seniorMemberlist\") {\n            seniorMemberlist = MemberlistLike(addr);\n        } else if (contractName == \"juniorMemberlist\") {\n            juniorMemberlist = MemberlistLike(addr);\n        } else if (contractName == \"navFeed\") {\n            navFeed = FeedLike(addr);\n        } else if (contractName == \"coordinator\") {\n            coordinator = CoordinatorLike(addr);\n        } else revert();\n        emit Depend(contractName, addr);\n    }\n\n    function file(bytes32 what, bool data) public level3 {\n        live = data;\n        emit File(what, data);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/lender/coordinator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./../fixed_point.sol\";\nimport \"@1754-factory/packages/src/auth/auth.sol\";\nimport \"@1754-factory/packages/src/math/math.sol\";\n\ninterface TrancheLike {\n    function epochUpdate(\n        uint256 epochID,\n        uint256 supplyFulfillment_,\n        uint256 redeemFulfillment_,\n        uint256 tokenPrice_,\n        uint256 epochSupplyCurrency,\n        uint256 epochRedeemCurrency\n    ) external;\n\n    function closeEpoch()\n        external\n        returns (uint256 totalSupply, uint256 totalRedeem);\n\n    function payoutRequestedCurrency() external;\n}\n\nabstract contract AssessorLike is FixedPoint {\n    // definitions\n    function calcSeniorRatio(\n        uint256 seniorAsset,\n        uint256 NAV,\n        uint256 reserve_\n    ) public pure virtual returns (uint256);\n\n    function calcSeniorAssetValue(\n        uint256 seniorRedeem,\n        uint256 seniorSupply,\n        uint256 currSeniorAsset,\n        uint256 reserve_,\n        uint256 nav_\n    ) public pure virtual returns (uint256 seniorAsset);\n\n    function calcSeniorRatio(\n        uint256 seniorRedeem,\n        uint256 seniorSupply,\n        uint256 currSeniorAsset,\n        uint256 newReserve,\n        uint256 nav\n    ) public pure virtual returns (uint256 seniorRatio);\n\n    // definitions based on assessor state\n    function calcSeniorTokenPrice(uint256 NAV, uint256 reserve)\n        public\n        virtual\n        returns (uint256 tokenPrice);\n\n    function calcJuniorTokenPrice(uint256 NAV, uint256 reserve)\n        public\n        virtual\n        returns (uint256 tokenPrice);\n\n    // get state\n    function maxReserve() public view virtual returns (uint256);\n\n    function calcUpdateNAV() public virtual returns (uint256);\n\n    function seniorDebt() public virtual returns (uint256);\n\n    function seniorBalance() public virtual returns (uint256);\n\n    function seniorRatioBounds()\n        public\n        view\n        virtual\n        returns (uint256 minSeniorRatio, uint256 maxSeniorRatio);\n\n    function totalBalance() public virtual returns (uint256);\n\n    // change state\n    function changeBorrowAmountEpoch(uint256 currencyAmount) public virtual;\n\n    function changeSeniorAsset(uint256 seniorSupply, uint256 seniorRedeem)\n        public\n        virtual;\n\n    function changeSeniorAsset(\n        uint256 seniorRatio,\n        uint256 seniorSupply,\n        uint256 seniorRedeem\n    ) public virtual;\n}\n\n// The EpochCoordinator keeps track of the epochs and execute epochs them.\n// An epoch execution happens with the maximum amount of redeem and supply which still satisfies\n// all constraints or at least improve certain pool constraints.\n// In most cases all orders can be fulfilled with order maximum without violating any constraints.\n// If it is not possible to satisfy all orders at maximum the coordinators opens a submission period.\n// The problem of finding the maximum amount of supply and redeem orders which still satisfies all constraints\n// can be seen as a linear programming (linear optimization problem).\n// The optimal solution can be calculated off-chain\ncontract EpochCoordinator is Auth, Math, FixedPoint {\n    struct OrderSummary {\n        // all variables are stored in currency\n        uint256 seniorRedeem;\n        uint256 juniorRedeem;\n        uint256 juniorSupply;\n        uint256 seniorSupply;\n    }\n\n    modifier minimumEpochTimePassed() {\n        require(safeSub(block.timestamp, lastEpochClosed) >= minimumEpochTime);\n        _;\n    }\n    // timestamp last epoch closed\n    uint256 public lastEpochClosed;\n    // default minimum length of an epoch\n    // (1 day, with 10 min buffer, so we can close the epochs automatically on a daily basis at the same time)\n    uint256 public minimumEpochTime = 1 days - 10 minutes;\n\n    TrancheLike public juniorTranche;\n    TrancheLike public seniorTranche;\n\n    AssessorLike public assessor;\n\n    uint256 public lastEpochExecuted;\n    uint256 public currentEpoch;\n    // current best solution submission for an epoch which satisfies all constraints\n    OrderSummary public bestSubmission;\n    // current best score of the best solution\n    uint256 public bestSubScore;\n    // flag which tracks if an submission period received a valid solution\n    bool public gotFullValidSolution;\n    // snapshot from the the orders in the tranches at epoch close\n    OrderSummary public order;\n    // snapshot from the senior token price at epoch close\n    Fixed27 public epochSeniorTokenPrice;\n    // snapshot from the junior token price at epoch close\n    Fixed27 public epochJuniorTokenPrice;\n\n    // snapshot from NAV (net asset value of the loans) at epoch close\n    uint256 public epochNAV;\n    // snapshot from the senior asset value at epoch close\n    uint256 public epochSeniorAsset;\n    // snapshot from reserve balance at epoch close\n    uint256 public epochReserve;\n    // flag which indicates if the coordinator is currently in a submission period\n    bool public submissionPeriod;\n\n    // weights of the scoring function\n    // highest priority senior redeem and junior redeem before junior and senior supply\n    uint256 public weightSeniorRedeem = 1000000;\n    uint256 public weightJuniorRedeem = 100000;\n    uint256 public weightJuniorSupply = 10000;\n    uint256 public weightSeniorSupply = 1000;\n\n    // challenge period end timestamp\n    uint256 public minChallengePeriodEnd;\n    // after a first valid solution is received others can submit better solutions\n    // until challenge time is over\n    uint256 public challengeTime;\n    // if the current state is not healthy improvement submissions are allowed\n    // ratio and reserve improvements receive score points\n    // keeping track of the best improvements scores\n    uint256 public bestRatioImprovement;\n    uint256 public bestReserveImprovement;\n\n    // flag for closing the pool (no new supplies allowed only redeem)\n    bool public poolClosing = false;\n\n    // constants\n    int256 public constant SUCCESS = 0;\n    int256 public constant NEW_BEST = 0;\n    int256 public constant ERR_CURRENCY_AVAILABLE = -1;\n    int256 public constant ERR_MAX_ORDER = -2;\n    int256 public constant ERR_MAX_RESERVE = -3;\n    int256 public constant ERR_MIN_SENIOR_RATIO = -4;\n    int256 public constant ERR_MAX_SENIOR_RATIO = -5;\n    int256 public constant ERR_NOT_NEW_BEST = -6;\n    int256 public constant ERR_POOL_CLOSING = -7;\n    uint256 public constant BIG_NUMBER = ONE * ONE;\n\n    event File(bytes32 indexed name, uint256 value);\n    event File(bytes32 indexed name, bool value);\n    event Depend(bytes32 indexed contractName, address addr);\n\n    constructor(uint256 challengeTime_) {\n        challengeTime = challengeTime_;\n        lastEpochClosed = block.timestamp;\n        currentEpoch = 1;\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function file(bytes32 name, uint256 value) public auth {\n        if (name == \"challengeTime\") {\n            challengeTime = value;\n        } else if (name == \"minimumEpochTime\") {\n            minimumEpochTime = value;\n        } else if (name == \"weightSeniorRedeem\") {\n            weightSeniorRedeem = value;\n        } else if (name == \"weightJuniorRedeem\") {\n            weightJuniorRedeem = value;\n        } else if (name == \"weightJuniorSupply\") {\n            weightJuniorSupply = value;\n        } else if (name == \"weightSeniorSupply\") {\n            weightSeniorSupply = value;\n        } else {\n            revert(\"unknown-name\");\n        }\n        emit File(name, value);\n    }\n\n    function file(bytes32 name, bool value) public auth {\n        if (name == \"poolClosing\") {\n            poolClosing = value;\n        } else {\n            revert(\"unknown-name\");\n        }\n        emit File(name, value);\n    }\n\n    // sets the dependency to another contract\n    function depend(bytes32 contractName, address addr) public auth {\n        if (contractName == \"juniorTranche\") {\n            juniorTranche = TrancheLike(addr);\n        } else if (contractName == \"seniorTranche\") {\n            seniorTranche = TrancheLike(addr);\n        } else if (contractName == \"assessor\") {\n            assessor = AssessorLike(addr);\n        } else revert();\n        emit Depend(contractName, addr);\n    }\n\n    // an epoch can be closed after a minimum epoch time has passed\n    // closeEpoch creates a snapshot of the current lender state\n    // if all orders can be fulfilled epoch is executed otherwise\n    // submission period starts\n    function closeEpoch()\n        external\n        minimumEpochTimePassed\n        returns (bool epochExecuted)\n    {\n        require(submissionPeriod == false);\n        lastEpochClosed = block.timestamp;\n        currentEpoch = currentEpoch + 1;\n        assessor.changeBorrowAmountEpoch(0);\n\n        (uint256 orderJuniorSupply, uint256 orderJuniorRedeem) = juniorTranche\n            .closeEpoch();\n        (uint256 orderSeniorSupply, uint256 orderSeniorRedeem) = seniorTranche\n            .closeEpoch();\n        epochSeniorAsset = safeAdd(\n            assessor.seniorDebt(),\n            assessor.seniorBalance()\n        );\n\n        // create a snapshot of the current lender state\n\n        epochNAV = assessor.calcUpdateNAV();\n        epochReserve = assessor.totalBalance();\n        //  if no orders exist epoch can be executed without validation\n        if (\n            orderSeniorRedeem == 0 &&\n            orderJuniorRedeem == 0 &&\n            orderSeniorSupply == 0 &&\n            orderJuniorSupply == 0\n        ) {\n            juniorTranche.epochUpdate(currentEpoch, 0, 0, 0, 0, 0);\n            seniorTranche.epochUpdate(currentEpoch, 0, 0, 0, 0, 0);\n            // assessor performs re-balancing\n            assessor.changeSeniorAsset(0, 0);\n            assessor.changeBorrowAmountEpoch(epochReserve);\n            lastEpochExecuted = safeAdd(lastEpochExecuted, 1);\n            return true;\n        }\n\n        // calculate current token prices which are used for the execute\n\n        epochSeniorTokenPrice = Fixed27(\n            assessor.calcSeniorTokenPrice(epochNAV, epochReserve)\n        );\n        epochJuniorTokenPrice = Fixed27(\n            assessor.calcJuniorTokenPrice(epochNAV, epochReserve)\n        );\n        // start closing the pool if juniorTranche lost everything\n        // the flag will change the behaviour of the validate function for not allowing new supplies\n        if (epochJuniorTokenPrice.value == 0) {\n            poolClosing = true;\n        }\n\n        // convert redeem orders in token into currency\n        order.seniorRedeem = rmul(\n            orderSeniorRedeem,\n            epochSeniorTokenPrice.value\n        );\n        order.juniorRedeem = rmul(\n            orderJuniorRedeem,\n            epochJuniorTokenPrice.value\n        );\n        order.juniorSupply = orderJuniorSupply;\n        order.seniorSupply = orderSeniorSupply;\n\n        // epoch is executed if orders can be fulfilled to 100% without constraint violation\n        if (\n            validate(\n                order.seniorRedeem,\n                order.juniorRedeem,\n                order.seniorSupply,\n                order.juniorSupply\n            ) == SUCCESS\n        ) {\n            _executeEpoch(\n                order.seniorRedeem,\n                order.juniorRedeem,\n                orderSeniorSupply,\n                orderJuniorSupply\n            );\n            return true;\n        }\n        // if 100% order fulfillment is not possible submission period starts\n        // challenge period time starts after first valid submission is received\n        submissionPeriod = true;\n        return false;\n    }\n\n    /// internal method to save new optimum\n    /// orders are expressed as currency\n    /// all parameter are 10^18\n    function _saveNewOptimum(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 juniorSupply,\n        uint256 seniorSupply,\n        uint256 score\n    ) internal {\n        bestSubmission.seniorRedeem = seniorRedeem;\n        bestSubmission.juniorRedeem = juniorRedeem;\n        bestSubmission.juniorSupply = juniorSupply;\n        bestSubmission.seniorSupply = seniorSupply;\n\n        bestSubScore = score;\n    }\n\n    // method to submit a solution for submission period\n    // anybody can submit a solution for the current execution epoch\n    // if solution satisfies all constraints (or at least improves an unhealthy state)\n    // and has the highest score\n    function submitSolution(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 juniorSupply,\n        uint256 seniorSupply\n    ) public returns (int256) {\n        require(submissionPeriod == true, \"submission-period-not-active\");\n\n        int256 valid = _submitSolution(\n            seniorRedeem,\n            juniorRedeem,\n            juniorSupply,\n            seniorSupply\n        );\n\n        // if solution is the first valid for this epoch the challenge period starts\n        if (valid == SUCCESS && minChallengePeriodEnd == 0) {\n            minChallengePeriodEnd = safeAdd(block.timestamp, challengeTime);\n        }\n        return valid;\n    }\n\n    // internal method for submit solution\n    function _submitSolution(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 juniorSupply,\n        uint256 seniorSupply\n    ) internal returns (int256) {\n        int256 valid = validate(\n            seniorRedeem,\n            juniorRedeem,\n            seniorSupply,\n            juniorSupply\n        );\n\n        // every solution needs to satisfy all core constraints\n        // there is no exception\n        if (\n            valid == ERR_CURRENCY_AVAILABLE ||\n            valid == ERR_MAX_ORDER ||\n            valid == ERR_POOL_CLOSING\n        ) {\n            // core constraint violated\n            return valid;\n        }\n\n        // all core constraints and all pool constraints are satisfied\n        if (valid == SUCCESS) {\n            uint256 score = scoreSolution(\n                seniorRedeem,\n                juniorRedeem,\n                seniorSupply,\n                juniorSupply\n            );\n\n            if (gotFullValidSolution == false) {\n                gotFullValidSolution = true;\n                _saveNewOptimum(\n                    seniorRedeem,\n                    juniorRedeem,\n                    juniorSupply,\n                    seniorSupply,\n                    score\n                );\n                // solution is new best => 0\n                return SUCCESS;\n            }\n\n            if (score < bestSubScore) {\n                // solution is not the best => -6\n                return ERR_NOT_NEW_BEST;\n            }\n\n            _saveNewOptimum(\n                seniorRedeem,\n                juniorRedeem,\n                juniorSupply,\n                seniorSupply,\n                score\n            );\n\n            // solution is new best => 0\n            return SUCCESS;\n        }\n\n        // proposed solution does not satisfy all pool constraints\n        // if we never received a solution which satisfies all constraints for this epoch\n        // we might accept it as an improvement\n        if (gotFullValidSolution == false) {\n            return\n                _improveScore(\n                    seniorRedeem,\n                    juniorRedeem,\n                    juniorSupply,\n                    seniorSupply\n                );\n        }\n\n        // proposed solution doesn't satisfy the pool constraints but a previous submission did\n        return ERR_NOT_NEW_BEST;\n    }\n\n    function absDistance(uint256 x, uint256 y)\n        public\n        pure\n        returns (uint256 delta)\n    {\n        if (x == y) {\n            // gas optimization: for avoiding an additional edge case of 0 distance\n            // distance is set to the smallest value possible\n            return 1;\n        }\n        if (x > y) {\n            return safeSub(x, y);\n        }\n        return safeSub(y, x);\n    }\n\n    function checkRatioInRange(\n        uint256 ratio,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) public pure returns (bool) {\n        if (ratio >= minRatio && ratio <= maxRatio) {\n            return true;\n        }\n        return false;\n    }\n\n    // calculates the improvement score of a solution\n    function _improveScore(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 juniorSupply,\n        uint256 seniorSupply\n    ) internal returns (int256) {\n        Fixed27 memory currSeniorRatio = Fixed27(\n            assessor.calcSeniorRatio(epochSeniorAsset, epochNAV, epochReserve)\n        );\n\n        int256 err = 0;\n        uint256 impScoreRatio = 0;\n        uint256 impScoreReserve = 0;\n\n        if (bestRatioImprovement == 0) {\n            // define no orders (current status) score as benchmark if no previous submission exists\n            // if the current state satisfies all pool constraints it has the highest score\n            (err, impScoreRatio, impScoreReserve) = scoreImprovement(\n                currSeniorRatio.value,\n                epochReserve\n            );\n            saveNewImprovement(impScoreRatio, impScoreReserve);\n        }\n\n        uint256 newReserve = calcNewReserve(\n            seniorRedeem,\n            juniorRedeem,\n            seniorSupply,\n            juniorSupply\n        );\n\n        Fixed27 memory newSeniorRatio = Fixed27(\n            assessor.calcSeniorRatio(\n                seniorRedeem,\n                seniorSupply,\n                epochSeniorAsset,\n                newReserve,\n                epochNAV\n            )\n        );\n\n        (err, impScoreRatio, impScoreReserve) = scoreImprovement(\n            newSeniorRatio.value,\n            newReserve\n        );\n\n        if (err == ERR_NOT_NEW_BEST) {\n            // solution is not the best => -1\n            return err;\n        }\n\n        saveNewImprovement(impScoreRatio, impScoreReserve);\n\n        // solution doesn't satisfy all pool constraints but improves the current violation\n        // improvement only gets 0 points only solutions in the feasible region receive more\n        _saveNewOptimum(\n            seniorRedeem,\n            juniorRedeem,\n            juniorSupply,\n            seniorSupply,\n            0\n        );\n        return NEW_BEST;\n    }\n\n    // the score improvement reserve uses the normalized distance to maxReserve/2 as score\n    // as smaller the distance as higher is the score\n    // highest possible score if solution is not violating the reserve\n    function scoreReserveImprovement(uint256 newReserve_)\n        public\n        view\n        returns (uint256 score)\n    {\n        if (newReserve_ <= assessor.maxReserve()) {\n            // highest possible score\n            return BIG_NUMBER;\n        }\n\n        return rdiv(ONE, safeSub(newReserve_, assessor.maxReserve()));\n    }\n\n    // the score improvement ratio uses the normalized distance to (minRatio+maxRatio)/2 as score\n    // as smaller the distance as higher is the score\n    // highest possible score if solution is not violating the ratio\n    function scoreRatioImprovement(uint256 newSeniorRatio)\n        public\n        view\n        returns (uint256)\n    {\n        (uint256 minSeniorRatio, uint256 maxSeniorRatio) = assessor\n            .seniorRatioBounds();\n        if (\n            checkRatioInRange(newSeniorRatio, minSeniorRatio, maxSeniorRatio) ==\n            true\n        ) {\n            // highest possible score\n            return BIG_NUMBER;\n        }\n        // absDistance of ratio can never be zero\n        return\n            rdiv(\n                ONE,\n                absDistance(\n                    newSeniorRatio,\n                    safeDiv(safeAdd(minSeniorRatio, maxSeniorRatio), 2)\n                )\n            );\n    }\n\n    // internal method to save new improvement score\n    function saveNewImprovement(uint256 impScoreRatio, uint256 impScoreReserve)\n        internal\n    {\n        bestRatioImprovement = impScoreRatio;\n        bestReserveImprovement = impScoreReserve;\n    }\n\n    // calculates improvement score for reserve and ratio pool constraints\n    function scoreImprovement(uint256 newSeniorRatio_, uint256 newReserve_)\n        public\n        view\n        returns (\n            int256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 impScoreRatio = scoreRatioImprovement(newSeniorRatio_);\n        uint256 impScoreReserve = scoreReserveImprovement(newReserve_);\n\n        // the highest priority has fixing the currentSeniorRatio\n        // if the ratio is improved, we can ignore reserve\n        if (impScoreRatio > bestRatioImprovement) {\n            // we found a new best\n            return (NEW_BEST, impScoreRatio, impScoreReserve);\n        }\n\n        // only if the submitted solution ratio score equals the current best ratio\n        // we determine if the submitted solution improves the reserve\n        if (impScoreRatio == bestRatioImprovement) {\n            if (impScoreReserve >= bestReserveImprovement) {\n                return (NEW_BEST, impScoreRatio, impScoreReserve);\n            }\n        }\n        return (ERR_NOT_NEW_BEST, impScoreRatio, impScoreReserve);\n    }\n\n    // scores a solution in the submission period\n    // the scoring function is a linear function with high weights as coefficient to determine\n    // the priorities. (non-preemptive goal programming)\n    function scoreSolution(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 juniorSupply,\n        uint256 seniorSupply\n    ) public view returns (uint256) {\n        // the default priority order\n        // 1. senior redeem\n        // 2. junior redeem\n        // 3. junior supply\n        // 4. senior supply\n        return\n            safeAdd(\n                safeAdd(\n                    safeMul(seniorRedeem, weightSeniorRedeem),\n                    safeMul(juniorRedeem, weightJuniorRedeem)\n                ),\n                safeAdd(\n                    safeMul(juniorSupply, weightJuniorSupply),\n                    safeMul(seniorSupply, weightSeniorSupply)\n                )\n            );\n    }\n\n    // validates if a solution satisfy the core constraints\n    // returns: first constraint which is not satisfied or success\n    function validateCoreConstraints(\n        uint256 currencyAvailable,\n        uint256 currencyOut,\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 seniorSupply,\n        uint256 juniorSupply\n    ) public view returns (int256 err) {\n        // constraint 1: currency available\n        if (currencyOut > currencyAvailable) {\n            // currencyAvailableConstraint => -1\n            return ERR_CURRENCY_AVAILABLE;\n        }\n\n        // constraint 2: max order\n        if (\n            seniorSupply > order.seniorSupply ||\n            juniorSupply > order.juniorSupply ||\n            seniorRedeem > order.seniorRedeem ||\n            juniorRedeem > order.juniorRedeem\n        ) {\n            // maxOrderConstraint => -2\n            return ERR_MAX_ORDER;\n        }\n\n        // successful => 0\n        return SUCCESS;\n    }\n\n    // validates if a solution satisfies the ratio constraints\n    // returns: first constraint which is not satisfied or success\n    function validateRatioConstraints(uint256 assets, uint256 seniorAsset)\n        public\n        view\n        returns (int256)\n    {\n        (uint256 minSeniorRatio, uint256 maxSeniorRatio) = assessor\n            .seniorRatioBounds();\n\n        // constraint 4: min senior ratio constraint\n        if (seniorAsset < rmul(assets, minSeniorRatio)) {\n            // minSeniorRatioConstraint => -4\n            return ERR_MIN_SENIOR_RATIO;\n        }\n        // constraint 5: max senior ratio constraint\n        if (seniorAsset > rmul(assets, maxSeniorRatio)) {\n            // maxSeniorRatioConstraint => -5\n            return ERR_MAX_SENIOR_RATIO;\n        }\n        // successful => 0\n        return SUCCESS;\n    }\n\n    // validates if a solution satisfies the pool constraints\n    // returns: first constraint which is not satisfied or success\n    function validatePoolConstraints(\n        uint256 reserve_,\n        uint256 seniorAsset,\n        uint256 nav_\n    ) public view returns (int256 err) {\n        // constraint 3: max reserve\n        if (reserve_ > assessor.maxReserve()) {\n            // maxReserveConstraint => -3\n            return ERR_MAX_RESERVE;\n        }\n\n        uint256 assets = safeAdd(nav_, reserve_);\n        return validateRatioConstraints(assets, seniorAsset);\n    }\n\n    // validates if a solution satisfies core and pool constraints\n    // returns: first constraint which is not satisfied or success\n    function validate(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 seniorSupply,\n        uint256 juniorSupply\n    ) public view returns (int256) {\n        return\n            validate(\n                epochReserve,\n                epochNAV,\n                epochSeniorAsset,\n                OrderSummary({\n                    seniorRedeem: seniorRedeem,\n                    juniorRedeem: juniorRedeem,\n                    seniorSupply: seniorSupply,\n                    juniorSupply: juniorSupply\n                })\n            );\n    }\n\n    function validate(\n        uint256 reserve_,\n        uint256 nav_,\n        uint256 seniorAsset_,\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 seniorSupply,\n        uint256 juniorSupply\n    ) public view returns (int256) {\n        return\n            validate(\n                reserve_,\n                nav_,\n                seniorAsset_,\n                OrderSummary({\n                    seniorRedeem: seniorRedeem,\n                    juniorRedeem: juniorRedeem,\n                    seniorSupply: seniorSupply,\n                    juniorSupply: juniorSupply\n                })\n            );\n    }\n\n    function validate(\n        uint256 reserve_,\n        uint256 nav_,\n        uint256 seniorAsset_,\n        OrderSummary memory trans\n    ) internal view returns (int256) {\n        uint256 currencyAvailable = safeAdd(\n            safeAdd(reserve_, trans.seniorSupply),\n            trans.juniorSupply\n        );\n        uint256 currencyOut = safeAdd(trans.seniorRedeem, trans.juniorRedeem);\n\n        int256 err = validateCoreConstraints(\n            currencyAvailable,\n            currencyOut,\n            trans.seniorRedeem,\n            trans.juniorRedeem,\n            trans.seniorSupply,\n            trans.juniorSupply\n        );\n\n        if (err != SUCCESS) {\n            return err;\n        }\n\n        uint256 newReserve = safeSub(currencyAvailable, currencyOut);\n        if (poolClosing == true) {\n            if (trans.seniorSupply == 0 && trans.juniorSupply == 0) {\n                return SUCCESS;\n            }\n            return ERR_POOL_CLOSING;\n        }\n        return\n            validatePoolConstraints(\n                newReserve,\n                assessor.calcSeniorAssetValue(\n                    trans.seniorRedeem,\n                    trans.seniorSupply,\n                    seniorAsset_,\n                    newReserve,\n                    nav_\n                ),\n                nav_\n            );\n    }\n\n    // public method to execute an epoch which required a submission period and the challenge period is over\n    function executeEpoch() public {\n        require(\n            block.timestamp >= minChallengePeriodEnd &&\n                minChallengePeriodEnd != 0\n        );\n\n        _executeEpoch(\n            bestSubmission.seniorRedeem,\n            bestSubmission.juniorRedeem,\n            bestSubmission.seniorSupply,\n            bestSubmission.juniorSupply\n        );\n    }\n\n    // calculates the percentage of an order type which can be fulfilled for an epoch\n    function calcFulfillment(uint256 amount, uint256 totalOrder)\n        public\n        pure\n        returns (uint256 percent)\n    {\n        if (amount == 0 || totalOrder == 0) {\n            return 0;\n        }\n        return rdiv(amount, totalOrder);\n    }\n\n    // calculates the new reserve after a solution would be executed\n    function calcNewReserve(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 seniorSupply,\n        uint256 juniorSupply\n    ) public view returns (uint256) {\n        return\n            safeSub(\n                safeAdd(safeAdd(epochReserve, seniorSupply), juniorSupply),\n                safeAdd(seniorRedeem, juniorRedeem)\n            );\n    }\n\n    // internal execute epoch communicates the order fulfillment of the best solution to the tranches\n    function _executeEpoch(\n        uint256 seniorRedeem,\n        uint256 juniorRedeem,\n        uint256 seniorSupply,\n        uint256 juniorSupply\n    ) internal {\n        uint256 epochID = safeAdd(lastEpochExecuted, 1);\n        submissionPeriod = false;\n\n        // tranche epochUpdates triggers currency transfers from/to reserve\n        // an mint/burn tokens\n        seniorTranche.epochUpdate(\n            epochID,\n            calcFulfillment(seniorSupply, order.seniorSupply),\n            calcFulfillment(seniorRedeem, order.seniorRedeem),\n            epochSeniorTokenPrice.value,\n            order.seniorSupply,\n            order.seniorRedeem\n        );\n\n        // assessor performs senior debt reBalancing according to new ratio\n        assessor.changeSeniorAsset(seniorSupply, seniorRedeem);\n\n        juniorTranche.epochUpdate(\n            epochID,\n            calcFulfillment(juniorSupply, order.juniorSupply),\n            calcFulfillment(juniorRedeem, order.juniorRedeem),\n            epochJuniorTokenPrice.value,\n            order.juniorSupply,\n            order.juniorRedeem\n        );\n\n        // sends requested currency to senior tranche, if currency was not available before\n        seniorTranche.payoutRequestedCurrency();\n\n        uint256 newReserve = calcNewReserve(\n            seniorRedeem,\n            juniorRedeem,\n            seniorSupply,\n            juniorSupply\n        );\n\n        // reBalancing again because the reserve has updated after the junior epochUpdate\n        assessor.changeSeniorAsset(0, 0);\n        // the new reserve after this epoch can be used for new loans\n        assessor.changeBorrowAmountEpoch(newReserve);\n\n        // reset state for next epochs\n        lastEpochExecuted = epochID;\n        minChallengePeriodEnd = 0;\n        bestSubScore = 0;\n        gotFullValidSolution = false;\n        bestRatioImprovement = 0;\n        bestReserveImprovement = 0;\n    }\n}\n"
    },
    "@1754-factory/packages/src/tokens/erc20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico, lucasvo\npragma solidity >=0.8.10;\n\ncontract ERC20 {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) public auth { wards[usr] = 1; }\n    function deny(address usr) public auth { wards[usr] = 0; }\n    modifier auth { require(wards[msg.sender] == 1); _; }\n\n    // --- ERC20 Data ---\n    uint8   public constant decimals = 18;\n    string  public name;\n    string  public symbol;\n    string  public constant version = \"1\";\n    uint256 public totalSupply;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n\n    event Approval(address indexed src, address indexed usr, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n\n    // --- Math ---\n    function safeAdd_(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-add-overflow\");\n    }\n    function safeSub_(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"math-sub-underflow\");\n    }\n\n    constructor(string memory symbol_, string memory name_) {\n        wards[msg.sender] = 1;\n        symbol = symbol_;\n        name = name_;\n\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    // --- ERC20 ---\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n    function transferFrom(address src, address dst, uint wad)\n        public virtual returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"cent/insufficient-balance\");\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\n            require(allowance[src][msg.sender] >= wad, \"cent/insufficient-allowance\");\n            allowance[src][msg.sender] = safeSub_(allowance[src][msg.sender], wad);\n        }\n        balanceOf[src] = safeSub_(balanceOf[src], wad);\n        balanceOf[dst] = safeAdd_(balanceOf[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n    function mint(address usr, uint wad) external virtual auth {\n        balanceOf[usr] = safeAdd_(balanceOf[usr], wad);\n        totalSupply    = safeAdd_(totalSupply, wad);\n        emit Transfer(address(0), usr, wad);\n    }\n    function burn(address usr, uint wad) public {\n        require(balanceOf[usr] >= wad, \"cent/insufficient-balance\");\n        if (usr != msg.sender && allowance[usr][msg.sender] != type(uint256).max) {\n            require(allowance[usr][msg.sender] >= wad, \"cent/insufficient-allowance\");\n            allowance[usr][msg.sender] = safeSub_(allowance[usr][msg.sender], wad);\n        }\n        balanceOf[usr] = safeSub_(balanceOf[usr], wad);\n        totalSupply    = safeSub_(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n    function approve(address usr, uint wad) external returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    // --- Alias ---\n    function push(address usr, uint wad) external {\n        transferFrom(msg.sender, usr, wad);\n    }\n    function pull(address usr, uint wad) external {\n        transferFrom(usr, msg.sender, wad);\n    }\n    function move(address src, address dst, uint wad) external {\n        transferFrom(src, dst, wad);\n    }\n    function burnFrom(address usr, uint wad) external {\n        burn(usr, wad);\n    }\n\n    // --- Approve by signature ---\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'cent/past-deadline');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'cent-erc20/invalid-sig');\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n}"
    },
    "@1754-factory/tinlake/src/lender/operator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\ninterface TrancheLike {\n    function supplyOrder(address usr, uint256 currencyAmount) external;\n\n    function redeemOrder(address usr, uint256 tokenAmount) external;\n\n    function disburse(address usr)\n        external\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        );\n\n    function disburse(address usr, uint256 endEpoch)\n        external\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        );\n\n    function currency() external view returns (address);\n}\n\ninterface RestrictedTokenLike {\n    function hasMember(address) external view returns (bool);\n}\n\ninterface EIP2612PermitLike {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface DaiPermitLike {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ncontract Operator is Auth {\n    TrancheLike public tranche;\n    RestrictedTokenLike public token;\n\n    // Events\n    event SupplyOrder(uint256 indexed amount);\n    event RedeemOrder(uint256 indexed amount);\n    event Depend(bytes32 indexed contractName, address addr);\n\n    constructor(address tranche_) {\n        tranche = TrancheLike(tranche_);\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // sets the dependency to another contract\n    function depend(bytes32 contractName, address addr) public auth {\n        if (contractName == \"tranche\") {\n            tranche = TrancheLike(addr);\n        } else if (contractName == \"token\") {\n            token = RestrictedTokenLike(addr);\n        } else revert();\n        emit Depend(contractName, addr);\n    }\n\n    // only investors that are on the memberlist can submit supplyOrders\n    function supplyOrder(uint256 amount) public {\n        require(\n            (token.hasMember(msg.sender) == true),\n            \"user-not-allowed-to-hold-token\"\n        );\n        tranche.supplyOrder(msg.sender, amount);\n        emit SupplyOrder(amount);\n    }\n\n    // only investors that are on the memberlist can submit redeemOrders\n    function redeemOrder(uint256 amount) public {\n        require(\n            (token.hasMember(msg.sender) == true),\n            \"user-not-allowed-to-hold-token\"\n        );\n        tranche.redeemOrder(msg.sender, amount);\n        emit RedeemOrder(amount);\n    }\n\n    // only investors that are on the memberlist can disburse\n    function disburse()\n        external\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        )\n    {\n        require(\n            (token.hasMember(msg.sender) == true),\n            \"user-not-allowed-to-hold-token\"\n        );\n        return tranche.disburse(msg.sender);\n    }\n\n    function disburse(uint256 endEpoch)\n        external\n        returns (\n            uint256 payoutCurrencyAmount,\n            uint256 payoutTokenAmount,\n            uint256 remainingSupplyCurrency,\n            uint256 remainingRedeemToken\n        )\n    {\n        require(\n            (token.hasMember(msg.sender) == true),\n            \"user-not-allowed-to-hold-token\"\n        );\n        return tranche.disburse(msg.sender, endEpoch);\n    }\n\n    // --- Permit Support ---\n    function supplyOrderWithDaiPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        DaiPermitLike(tranche.currency()).permit(\n            msg.sender,\n            address(tranche),\n            nonce,\n            expiry,\n            true,\n            v,\n            r,\n            s\n        );\n        supplyOrder(amount);\n    }\n\n    function supplyOrderWithPermit(\n        uint256 amount,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        EIP2612PermitLike(tranche.currency()).permit(\n            msg.sender,\n            address(tranche),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        supplyOrder(amount);\n    }\n\n    function redeemOrderWithPermit(\n        uint256 amount,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        EIP2612PermitLike(address(token)).permit(\n            msg.sender,\n            address(tranche),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        redeemOrder(amount);\n    }\n}\n"
    },
    "@1754-factory/tinlake/src/borrower/shelf.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/math/math.sol\";\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\nimport {TitleOwned, TitleLike} from \"@1754-factory/packages/src/ownership/title.sol\";\n\ninterface NFTLike {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface TokenLike {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function approve(address, uint256) external;\n}\n\ninterface PileLike {\n    function total() external view returns (uint256);\n\n    function debt(uint256) external returns (uint256);\n\n    function accrue(uint256) external;\n\n    function incDebt(uint256, uint256) external;\n\n    function decDebt(uint256, uint256) external;\n}\n\ninterface NAVFeedLike {\n    function borrow(uint256 loan, uint256 currencyAmount) external;\n\n    function repay(uint256 loan, uint256 currencyAmount) external;\n\n    function presentValue(uint256 loan) external view returns (uint256);\n\n    function futureValue(uint256 loan) external view returns (uint256);\n\n    function zeroPV(uint256 loan) external view returns (bool);\n}\n\ninterface ReserveLike {\n    function deposit(uint256 currencyAmount) external;\n\n    function payoutForLoans(uint256 currencyAmount) external;\n}\n\ninterface SubscriberLike {\n    function borrowEvent(uint256 loan, uint256 amount) external;\n\n    function repayEvent(uint256 loan, uint256 amount) external;\n\n    function lockEvent(uint256 loan) external;\n\n    function unlockEvent(uint256 loan) external;\n}\n\ninterface AssessorLike {\n    function reBalance() external;\n}\n\ncontract Shelf is Auth, TitleOwned, Math {\n    // --- Data ---\n    NAVFeedLike public ceiling;\n    PileLike public pile;\n    TokenLike public currency;\n    ReserveLike public reserve;\n    AssessorLike public assessor;\n    SubscriberLike public subscriber;\n\n    uint256 public balance;\n\n    struct Loan {\n        address registry;\n        uint256 tokenId;\n    }\n\n    mapping(uint256 => uint256) public balances;\n    mapping(uint256 => Loan) public shelf;\n    mapping(bytes32 => uint256) public nftlookup;\n\n    // Events\n    event Close(uint256 indexed loan);\n    event Issue(address indexed registry_, uint256 indexed token_);\n    event Borrow(uint256 indexed loan, uint256 currencyAmount);\n    event Withdraw(uint256 indexed loan, uint256 currencyAmount, address usr);\n    event Repay(uint256 indexed loan, uint256 currencyAmount);\n    event Recover(uint256 indexed loan, address usr, uint256 currencyAmount);\n    event Lock(uint256 indexed loan);\n    event Unlock(uint256 indexed loan);\n    event Claim(uint256 indexed loan, address usr);\n    event Depend(bytes32 indexed contractName, address addr);\n\n    constructor(\n        address currency_,\n        address title_,\n        address pile_,\n        address ceiling_\n    ) TitleOwned(title_) {\n        currency = TokenLike(currency_);\n        pile = PileLike(pile_);\n        ceiling = NAVFeedLike(ceiling_);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // sets the dependency to another contract\n    function depend(bytes32 contractName, address addr) external auth {\n        if (contractName == \"token\") {\n            currency = TokenLike(addr);\n        } else if (contractName == \"title\") {\n            title = TitleLike(addr);\n        } else if (contractName == \"pile\") {\n            pile = PileLike(addr);\n        } else if (contractName == \"ceiling\") {\n            ceiling = NAVFeedLike(addr);\n        } else if (contractName == \"reserve\") {\n            if (address(reserve) != address(0))\n                currency.approve(address(reserve), uint256(0));\n            currency.approve(addr, type(uint256).max);\n            reserve = ReserveLike(addr);\n        } else if (contractName == \"assessor\") {\n            assessor = AssessorLike(addr);\n        } else if (contractName == \"subscriber\") {\n            subscriber = SubscriberLike(addr);\n        } else revert();\n        emit Depend(contractName, addr);\n    }\n\n    function token(uint256 loan)\n        public\n        view\n        returns (address registry, uint256 nft)\n    {\n        return (shelf[loan].registry, shelf[loan].tokenId);\n    }\n\n    // issues a new loan in Tinlake - it requires the ownership of an nft\n    // first step in the loan process - everyone could add an nft\n    function issue(address registry_, uint256 token_)\n        external\n        returns (uint256)\n    {\n        require(\n            NFTLike(registry_).ownerOf(token_) == msg.sender,\n            \"nft-not-owned\"\n        );\n        bytes32 nft = keccak256(abi.encodePacked(registry_, token_));\n        require(nftlookup[nft] == 0, \"nft-in-use\");\n        uint256 loan = title.issue(msg.sender);\n        nftlookup[nft] = loan;\n        shelf[loan].registry = registry_;\n        shelf[loan].tokenId = token_;\n\n        emit Issue(registry_, token_);\n        return loan;\n    }\n\n    function close(uint256 loan) external {\n        require(!nftLocked(loan), \"nft-locked\");\n        (address registry, uint256 tokenId) = token(loan);\n        require(\n            title.ownerOf(loan) == msg.sender ||\n                NFTLike(registry).ownerOf(tokenId) == msg.sender,\n            \"not-loan-or-nft-owner\"\n        );\n        title.close(loan);\n        bytes32 nft = keccak256(\n            abi.encodePacked(shelf[loan].registry, shelf[loan].tokenId)\n        );\n        nftlookup[nft] = 0;\n        _resetLoanBalance(loan);\n        emit Close(loan);\n    }\n\n    // starts the borrow process of a loan\n    // informs the system of the requested currencyAmount\n    // interest accumulation starts with this method\n    // the method can only be called if the nft is locked\n    // a max ceiling needs to be defined by an oracle\n    function borrow(uint256 loan, uint256 currencyAmount) external owner(loan) {\n        require(nftLocked(loan), \"nft-not-locked\");\n\n        if (address(subscriber) != address(0)) {\n            subscriber.borrowEvent(loan, currencyAmount);\n        }\n\n        pile.accrue(loan);\n\n        balances[loan] = safeAdd(balances[loan], currencyAmount);\n        balance = safeAdd(balance, currencyAmount);\n\n        // payout to shelf\n        reserve.payoutForLoans(currencyAmount);\n\n        // increase NAV\n        ceiling.borrow(loan, currencyAmount);\n        pile.incDebt(loan, currencyAmount);\n\n        // reBalance lender interest bearing amount based on new NAV\n        assessor.reBalance();\n\n        emit Borrow(loan, currencyAmount);\n    }\n\n    // withdraw transfers the currency to the borrower account\n    function withdraw(\n        uint256 loan,\n        uint256 currencyAmount,\n        address usr\n    ) external owner(loan) {\n        require(nftLocked(loan), \"nft-not-locked\");\n        require(currencyAmount <= balances[loan], \"withdraw-amount-too-high\");\n\n        balances[loan] = safeSub(balances[loan], currencyAmount);\n        balance = safeSub(balance, currencyAmount);\n        require(\n            currency.transfer(usr, currencyAmount),\n            \"currency-transfer-failed\"\n        );\n        emit Withdraw(loan, currencyAmount, usr);\n    }\n\n    // repays the entire or partial debt of a loan\n    function repay(uint256 loan, uint256 currencyAmount) external owner(loan) {\n        require(nftLocked(loan), \"nft-not-locked\");\n        require(balances[loan] == 0, \"withdraw-required-before-repay\");\n\n        if (address(subscriber) != address(0)) {\n            subscriber.repayEvent(loan, currencyAmount);\n        }\n\n        pile.accrue(loan);\n        uint256 loanDebt = pile.debt(loan);\n\n        // only repay max loan debt\n        if (currencyAmount > loanDebt) {\n            currencyAmount = loanDebt;\n        }\n        require(\n            currency.transferFrom(msg.sender, address(this), currencyAmount),\n            \"currency-transfer-failed\"\n        );\n        ceiling.repay(loan, currencyAmount);\n        pile.decDebt(loan, currencyAmount);\n        reserve.deposit(currencyAmount);\n\n        // reBalance lender interest bearing amount based on new NAV\n        assessor.reBalance();\n\n        emit Repay(loan, currencyAmount);\n    }\n\n    // a collector can recover defaulted loans\n    // it is not required to recover the entire loan debt\n    function recover(\n        uint256 loan,\n        address usr,\n        uint256 currencyAmount\n    ) external auth {\n        pile.accrue(loan);\n\n        uint256 loanDebt = pile.debt(loan);\n\n        require(\n            currency.transferFrom(usr, address(this), currencyAmount),\n            \"currency-transfer-failed\"\n        );\n\n        ceiling.repay(loan, loanDebt);\n        // sets loan debt to 0\n        pile.decDebt(loan, loanDebt);\n        _resetLoanBalance(loan);\n        reserve.deposit(currencyAmount);\n        // reBalance lender interest bearing amount based on new NAV\n        assessor.reBalance();\n        emit Recover(loan, usr, currencyAmount);\n    }\n\n    function _repay(\n        uint256 loan,\n        address usr,\n        uint256 currencyAmount\n    ) internal {\n        pile.accrue(loan);\n        uint256 loanDebt = pile.debt(loan);\n\n        // only repay max loan debt\n        if (currencyAmount > loanDebt) {\n            currencyAmount = loanDebt;\n        }\n        require(\n            currency.transferFrom(usr, address(this), currencyAmount),\n            \"currency-transfer-failed\"\n        );\n        ceiling.repay(loan, currencyAmount);\n        pile.decDebt(loan, currencyAmount);\n\n        reserve.deposit(currencyAmount);\n        // reBalance lender interest bearing amount based on new NAV\n        assessor.reBalance();\n    }\n\n    // locks an nft in the shelf\n    // requires an issued loan\n    function lock(uint256 loan) external owner(loan) {\n        if (address(subscriber) != address(0)) {\n            subscriber.lockEvent(loan);\n        }\n        NFTLike(shelf[loan].registry).transferFrom(\n            msg.sender,\n            address(this),\n            shelf[loan].tokenId\n        );\n        emit Lock(loan);\n    }\n\n    // unlocks an nft in the shelf\n    // requires zero debt or 100% write off\n    function unlock(uint256 loan) external owner(loan) {\n        // loans can be unlocked and closed when the debt is 0, or the loan is written off 100%\n        uint256 debt_ = pile.debt(loan);\n\n        require(\n            debt_ == 0 || ceiling.zeroPV(loan),\n            \"loan-has-outstanding-debt\"\n        );\n\n        if (address(subscriber) != address(0)) {\n            subscriber.unlockEvent(loan);\n        }\n\n        NFTLike(shelf[loan].registry).transferFrom(\n            address(this),\n            msg.sender,\n            shelf[loan].tokenId\n        );\n\n        emit Unlock(loan);\n    }\n\n    function nftLocked(uint256 loan) public view returns (bool) {\n        return\n            NFTLike(shelf[loan].registry).ownerOf(shelf[loan].tokenId) ==\n            address(this);\n    }\n\n    // a loan can be claimed by a collector if the loan debt is above the loan threshold\n    // transfers the nft to the collector\n    function claim(uint256 loan, address usr) public auth {\n        NFTLike(shelf[loan].registry).transferFrom(\n            address(this),\n            usr,\n            shelf[loan].tokenId\n        );\n        emit Claim(loan, usr);\n    }\n\n    function _resetLoanBalance(uint256 loan) internal {\n        uint256 loanBalance = balances[loan];\n        if (loanBalance > 0) {\n            balances[loan] = 0;\n            balance = safeSub(balance, loanBalance);\n        }\n    }\n\n    // returns the total number of loans including closed loans\n    function loanCount() public view returns (uint256) {\n        return title.count();\n    }\n}\n"
    },
    "@1754-factory/packages/src/ownership/title.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { Auth } from \"../auth/auth.sol\";\n\ncontract Title is Auth, ERC721 {\n    // --- Data ---\n    uint public count;\n\n    constructor (string memory name, string memory symbol) ERC721(name, symbol) {\n        wards[msg.sender] = 1;\n        count = 1;\n    }\n\n    // --- Title ---\n    function issue (address usr) public auth returns (uint) {\n        return _issue(usr);\n    }\n\n    function _issue (address usr) internal returns (uint) {\n        _mint(usr, count);\n        count += 1; // can't overflow, not enough gas in the world to pay for 2**256 nfts.\n        return count-1;\n    }\n\n    function close (uint tkn) public auth {\n        _burn(tkn);\n    }\n}\n\ninterface TitleLike {\n    function issue(address) external returns (uint);\n    function close(uint) external;\n    function ownerOf (uint) external view returns (address);\n    function count () external view returns (uint);\n}\n\ncontract TitleOwned {\n    TitleLike title;\n    constructor (address title_) {\n        title = TitleLike(title_);\n    }\n\n    modifier owner (uint loan) { require(title.ownerOf(loan) == msg.sender); _; }\n}"
    },
    "@1754-factory/tinlake/src/borrower/pile.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) 2018  Rain <rainbreak@riseup.net>, Centrifuge\npragma solidity ^0.8.10;\n\nimport \"@1754-factory/packages/src/math/interest.sol\";\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\n// ## Interest Group based Pile\n// The following is one implementation of a debt module. It keeps track of different buckets of interest rates and is optimized for many loans per interest bucket. It keeps track of interest\n// rate accumulators (chi values) for all interest rate categories. It calculates debt each\n// loan according to its interest rate category and pie value.\ncontract Pile is Auth, Interest {\n    // --- Data ---\n\n    // stores all needed information of an interest rate group\n    struct Rate {\n        uint256 pie; // Total debt of all loans with this rate\n        uint256 chi; // Accumulated rates\n        uint256 ratePerSecond; // Accumulation per second\n        uint48 lastUpdated; // Last time the rate was accumulated\n        uint256 fixedRate; // fixed rate applied to each loan of the group\n    }\n\n    // Interest Rate Groups are identified by a `uint` and stored in a mapping\n    mapping(uint256 => Rate) public rates;\n\n    // mapping of all loan debts\n    // the debt is stored as pie\n    // pie is defined as pie = debt/chi therefore debt = pie * chi\n    // where chi is the accumulated interest rate index over time\n    mapping(uint256 => uint256) public pie;\n    // loan => rate\n    mapping(uint256 => uint256) public loanRates;\n\n    // Events\n    event IncreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event DecreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event SetRate(uint256 indexed loan, uint256 rate);\n    event ChangeRate(uint256 indexed loan, uint256 newRate);\n    event File(bytes32 indexed what, uint256 rate, uint256 value);\n\n    constructor() {\n        // pre-definition for loans without interest rates\n        rates[0].chi = ONE;\n        rates[0].ratePerSecond = ONE;\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Public Debt Methods  ---\n    // increases the debt of a loan by a currencyAmount\n    // a change of the loan debt updates the rate debt and total debt\n    function incDebt(uint256 loan, uint256 currencyAmount) external auth {\n        uint256 rate = loanRates[loan];\n        require(\n            block.timestamp == rates[rate].lastUpdated,\n            \"rate-group-not-updated\"\n        );\n        currencyAmount = safeAdd(\n            currencyAmount,\n            rmul(currencyAmount, rates[rate].fixedRate)\n        );\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = safeAdd(pie[loan], pieAmount);\n        rates[rate].pie = safeAdd(rates[rate].pie, pieAmount);\n\n        emit IncreaseDebt(loan, currencyAmount);\n    }\n\n    // decrease the loan's debt by a currencyAmount\n    // a change of the loan debt updates the rate debt and total debt\n    function decDebt(uint256 loan, uint256 currencyAmount) external auth {\n        uint256 rate = loanRates[loan];\n        require(\n            block.timestamp == rates[rate].lastUpdated,\n            \"rate-group-not-updated\"\n        );\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = safeSub(pie[loan], pieAmount);\n        rates[rate].pie = safeSub(rates[rate].pie, pieAmount);\n\n        emit DecreaseDebt(loan, currencyAmount);\n    }\n\n    // returns the current debt based on actual block.timestamp (now)\n    function debt(uint256 loan) external view returns (uint256) {\n        uint256 rate_ = loanRates[loan];\n        uint256 chi_ = rates[rate_].chi;\n        if (block.timestamp >= rates[rate_].lastUpdated) {\n            chi_ = chargeInterest(\n                rates[rate_].chi,\n                rates[rate_].ratePerSecond,\n                rates[rate_].lastUpdated\n            );\n        }\n        return toAmount(chi_, pie[loan]);\n    }\n\n    // returns the total debt of a interest rate group\n    function rateDebt(uint256 rate) external view returns (uint256) {\n        uint256 chi_ = rates[rate].chi;\n        uint256 pie_ = rates[rate].pie;\n\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            chi_ = chargeInterest(\n                rates[rate].chi,\n                rates[rate].ratePerSecond,\n                rates[rate].lastUpdated\n            );\n        }\n        return toAmount(chi_, pie_);\n    }\n\n    // --- Interest Rate Group Implementation ---\n\n    // set rate loanRates for a loan\n    function setRate(uint256 loan, uint256 rate) external auth {\n        require(pie[loan] == 0, \"non-zero-debt\");\n        // rate category has to be initiated\n        require(rates[rate].chi != 0, \"rate-group-not-set\");\n        loanRates[loan] = rate;\n        emit SetRate(loan, rate);\n    }\n\n    // change rate loanRates for a loan\n    function changeRate(uint256 loan, uint256 newRate) external auth {\n        require(rates[newRate].chi != 0, \"rate-group-not-set\");\n        uint256 currentRate = loanRates[loan];\n        drip(currentRate);\n        drip(newRate);\n        uint256 pie_ = pie[loan];\n        uint256 debt_ = toAmount(rates[currentRate].chi, pie_);\n        rates[currentRate].pie = safeSub(rates[currentRate].pie, pie_);\n        pie[loan] = toPie(rates[newRate].chi, debt_);\n        rates[newRate].pie = safeAdd(rates[newRate].pie, pie[loan]);\n        loanRates[loan] = newRate;\n        emit ChangeRate(loan, newRate);\n    }\n\n    // set/change the interest rate of a rate category\n    function file(\n        bytes32 what,\n        uint256 rate,\n        uint256 value\n    ) external auth {\n        if (what == \"rate\") {\n            require(value != 0, \"rate-per-second-can-not-be-0\");\n            if (rates[rate].chi == 0) {\n                rates[rate].chi = ONE;\n                rates[rate].lastUpdated = uint48(block.timestamp);\n            } else {\n                drip(rate);\n            }\n            rates[rate].ratePerSecond = value;\n        } else if (what == \"fixedRate\") {\n            rates[rate].fixedRate = value;\n        } else revert(\"unknown parameter\");\n\n        emit File(what, rate, value);\n    }\n\n    // accrue needs to be called before any debt amounts are modified by an external component\n    function accrue(uint256 loan) external {\n        drip(loanRates[loan]);\n    }\n\n    // drip updates the chi of the rate category by compounding the interest and\n    // updates the total debt\n    function drip(uint256 rate) public {\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            (uint256 chi, ) = compounding(\n                rates[rate].chi,\n                rates[rate].ratePerSecond,\n                rates[rate].lastUpdated,\n                rates[rate].pie\n            );\n            rates[rate].chi = chi;\n            rates[rate].lastUpdated = uint48(block.timestamp);\n        }\n    }\n}\n"
    },
    "src/Borrowers/PermissionedBorrower.sol": {
      "content": "pragma solidity ^0.8.13;\n\nimport \"@1754-factory/tinlake/src/borrower/shelf.sol\";\nimport \"@1754-factory/tinlake/src/lender/operator.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PermissionedBorrower is Ownable {}\n"
    },
    "src/Interest/InterestModule.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) 2018  Rain <rainbreak@riseup.net>, Centrifuge\npragma solidity ^0.8.13;\n\nimport \"@1754-factory/packages/src/math/interest.sol\";\nimport \"@1754-factory/packages/src/auth/auth.sol\";\n\n// ## Interest Group based Pile\n// The following is one implementation of a debt module. It keeps track of different buckets of interest rates and is optimized for many loans per interest bucket. It keeps track of interest\n// rate accumulators (chi values) for all interest rate categories. It calculates debt each\n// loan according to its interest rate category and pie value.\ncontract InterestModule is Auth, Interest {\n    // --- Data ---\n\n    // stores all needed information of an interest rate group\n    struct Rate {\n        uint256 pie; // Total debt of all loans with this rate\n        uint256 chi; // Accumulated rates\n        uint256 ratePerSecond; // Accumulation per second\n        uint48 lastUpdated; // Last time the rate was accumulated\n        uint256 fixedRate; // fixed rate applied to each loan of the group\n    }\n\n    // Interest Rate Groups are identified by a `uint` and stored in a mapping\n    mapping(uint256 => Rate) public rates;\n\n    // mapping of all loan debts\n    // the debt is stored as pie\n    // pie is defined as pie = debt/chi therefore debt = pie * chi\n    // where chi is the accumulated interest rate index over time\n    mapping(uint256 => uint256) public pie;\n    // loan => rate\n    mapping(uint256 => uint256) public loanRates;\n\n    // Events\n    event IncreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event DecreaseDebt(uint256 indexed loan, uint256 currencyAmount);\n    event SetRate(uint256 indexed loan, uint256 rate);\n    event ChangeRate(uint256 indexed loan, uint256 newRate);\n    event File(bytes32 indexed what, uint256 rate, uint256 value);\n\n    constructor() {\n        // pre-definition for loans without interest rates\n        rates[0].chi = ONE;\n        rates[0].ratePerSecond = ONE;\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Public Debt Methods  ---\n    // increases the debt of a loan by a currencyAmount\n    // a change of the loan debt updates the rate debt and total debt\n    function incDebt(uint256 loan, uint256 currencyAmount) external auth {\n        uint256 rate = loanRates[loan];\n        require(\n            block.timestamp == rates[rate].lastUpdated,\n            \"rate-group-not-updated\"\n        );\n        currencyAmount = (currencyAmount +\n            rmul(currencyAmount, rates[rate].fixedRate));\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = (pie[loan] + pieAmount);\n        rates[rate].pie = (rates[rate].pie + pieAmount);\n\n        emit IncreaseDebt(loan, currencyAmount);\n    }\n\n    // decrease the loan's debt by a currencyAmount\n    // a change of the loan debt updates the rate debt and total debt\n    function decDebt(uint256 loan, uint256 currencyAmount) external auth {\n        uint256 rate = loanRates[loan];\n        require(\n            block.timestamp == rates[rate].lastUpdated,\n            \"rate-group-not-updated\"\n        );\n        uint256 pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = (pie[loan] + pieAmount);\n        rates[rate].pie = (rates[rate].pie + pieAmount);\n\n        emit DecreaseDebt(loan, currencyAmount);\n    }\n\n    // returns the current debt based on actual block.timestamp (now)\n    function debt(uint256 loan) external view returns (uint256) {\n        uint256 rate_ = loanRates[loan];\n        uint256 chi_ = rates[rate_].chi;\n        if (block.timestamp >= rates[rate_].lastUpdated) {\n            chi_ = chargeInterest(\n                rates[rate_].chi,\n                rates[rate_].ratePerSecond,\n                rates[rate_].lastUpdated\n            );\n        }\n        return toAmount(chi_, pie[loan]);\n    }\n\n    // returns the total debt of a interest rate group\n    function rateDebt(uint256 rate) external view returns (uint256) {\n        uint256 chi_ = rates[rate].chi;\n        uint256 pie_ = rates[rate].pie;\n\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            chi_ = chargeInterest(\n                rates[rate].chi,\n                rates[rate].ratePerSecond,\n                rates[rate].lastUpdated\n            );\n        }\n        return toAmount(chi_, pie_);\n    }\n\n    // --- Interest Rate Group Implementation ---\n\n    // set rate loanRates for a loan\n    function setRate(uint256 loan, uint256 rate) external auth {\n        require(pie[loan] == 0, \"non-zero-debt\");\n        // rate category has to be initiated\n        require(rates[rate].chi != 0, \"rate-group-not-set\");\n        loanRates[loan] = rate;\n        emit SetRate(loan, rate);\n    }\n\n    // change rate loanRates for a loan\n    function changeRate(uint256 loan, uint256 newRate) external auth {\n        require(rates[newRate].chi != 0, \"rate-group-not-set\");\n        uint256 currentRate = loanRates[loan];\n        drip(currentRate);\n        drip(newRate);\n        uint256 pie_ = pie[loan];\n        uint256 debt_ = toAmount(rates[currentRate].chi, pie_);\n        rates[currentRate].pie = (rates[currentRate].pie + pie_);\n        pie[loan] = toPie(rates[newRate].chi, debt_);\n        rates[newRate].pie = (rates[newRate].pie + pie[loan]);\n        loanRates[loan] = newRate;\n        emit ChangeRate(loan, newRate);\n    }\n\n    function newLoan(\n        uint256 loan,\n        uint256 ratePerSecond,\n        uint256 fixedRate\n    ) external auth {\n        rates[loan].chi = ONE;\n        rates[loan].lastUpdated = uint48(block.timestamp);\n        rates[loan].ratePerSecond = ONE; //ratePerSecond - ratePerSecond;\n        rates[loan].fixedRate = fixedRate;\n        loanRates[loan] = loan;\n    }\n\n    // set/change the interest rate of a rate category\n    function file(\n        bytes32 what,\n        uint256 rate,\n        uint256 value\n    ) external auth {\n        if (what == \"rate\") {\n            require(value != 0, \"rate-per-second-can-not-be-0\");\n            if (rates[rate].chi == 0) {\n                rates[rate].chi = ONE;\n                rates[rate].lastUpdated = uint48(block.timestamp);\n            } else {\n                drip(rate);\n            }\n            rates[rate].ratePerSecond = value;\n        } else if (what == \"fixedRate\") {\n            rates[rate].fixedRate = value;\n        } else revert(\"unknown parameter\");\n\n        emit File(what, rate, value);\n    }\n\n    // accrue needs to be called before any debt amounts are modified by an external component\n    function accrue(uint256 loan) external {\n        drip(loanRates[loan]);\n    }\n\n    // drip updates the chi of the rate category by compounding the interest and\n    // updates the total debt\n    function drip(uint256 rate) public {\n        if (block.timestamp >= rates[rate].lastUpdated) {\n            (uint256 chi, ) = compounding(\n                rates[rate].chi,\n                rates[rate].ratePerSecond,\n                rates[rate].lastUpdated,\n                rates[rate].pie\n            );\n            rates[rate].chi = chi;\n            rates[rate].lastUpdated = uint48(block.timestamp);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "src/Delegators/Delegator.sol": {
      "content": "pragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Delegator is AccessControl {\n    bytes32 public constant DELEGATOR = keccak256(\"DELEGATOR_ROLE\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n\n    struct CreditProposal {\n        uint8 totalVotes;\n        uint8 votesFor;\n    }\n\n    uint8 threshold;\n    address fund;\n\n    mapping(address => CreditProposal) proposals; // Maps beneficiary to Proposal struct\n    mapping(address => mapping(address => uint8)) votes; // 0 -> havent voted, 1 -> voted no, 2 -> voted yes\n\n    event VoteCast(\n        address indexed beneficiary,\n        address indexed voter,\n        bool approved\n    );\n    event LoanApproved(address indexed beneficiary);\n    event LoanDenied(address indexed beneficiary);\n\n    error AlreadyVoted(address beneficiary, address voter);\n    error ProposalNotActive(address beneficiary);\n\n    constructor(\n        address _owner,\n        address _fund,\n        address[] memory _initialDelegators,\n        uint8 _threshold\n    ) {\n        _grantRole(OWNER, _owner);\n        threshold = _threshold;\n        fund = _fund;\n\n        for (uint8 i = 0; i < _initialDelegators.length; i++) {\n            _grantRole(DELEGATOR, _initialDelegators[i]);\n        }\n    }\n\n    modifier newVote(address loanId) {\n        if (votes[loanId][msg.sender] > 0)\n            revert AlreadyVoted(loanId, msg.sender);\n        _;\n    }\n\n    function isApproved(address beneficiary) external view returns (bool) {\n        CreditProposal memory prop = proposals[beneficiary];\n        return prop.votesFor >= threshold;\n    }\n\n    function vote(address beneficiary, bool approved)\n        external\n        onlyRole(DELEGATOR)\n        newVote(beneficiary)\n    {\n        CreditProposal memory prop = proposals[beneficiary];\n        prop.totalVotes++;\n        if (approved) prop.votesFor++;\n\n        emit VoteCast(beneficiary, msg.sender, approved);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}